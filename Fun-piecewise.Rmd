# Piecewise functions {#fun-piecewise}



::: {.objectives}
```{r echo=FALSE, results="asis"}
state_objective("Fun-4-b-4a", "Identify graphs of a piecewise linear function.")
state_objective("Fun-1C-d", "Construct a hock-stick function by piecewise combination of a constant function and a straight-line function with non-zero slope.")
state_objective("Fun-4-b-4b", "Recognize traditional curly-brace notation for piecewise functions.")
state_objective("Fun-4-b-4c", "Be able to create a piecewise function in R.")
state_objective("Fun-4-b-4d", "Distinguish between continuous and discontinuous functions")
```
:::

Each of our basic modeling functions, with two exceptions, has a domain that is the entire number line $-\infty < x < \infty$. No matter how big or small is the value of the input, the function has an output. Such functions are particularly nice to work with, since we never have to worry about the input going out of bounds.

The two exceptions are:

1. the logarithm function, which is defined only for $0 < x$.
2. some of the power-law functions: $x^p$. 
    - When $p$ is negative, the output of the function is undefined when $x=0$. You can see why with a simple example: $g(x) \equiv x^{-2}$. Most students had it drilled into them that "division by zero is illegal," and $g(0) = \frac{1}{0} \frac{1}{0}$, a double law breaker. 
    - When $p$ is not an integer, that is $p \neq 1, 2, 3, \cdots$ the domain of the power-law function does not include negative inputs. To see why, consider the function $h(x) \equiv x^{1/3}$. 
    
It can be tedious to make sure that you are on the right side of the law when dealing with functions whose domain is not the whole number line. The designers of the hardware that does computer arithmetic, after several decades of work, found a clever system to make it easier. It's a standard part of such hardware that whenever ta function is handed an input that is not part of that function's domain, one of two special "numbers" is returned. To illustrate:
```{r warning=FALSE}
sqrt(-3)
(-2)^0.9999
1/0
```
`NaN` stands for "not a number." Just about any calculation involving `NaN` will generate `NaN` as a result, even those involving multiplication by zero or cancellation by subtraction or division.^[One that does produce a number is `NaN^0`.] For instance:
```{r warning=FALSE}
0 * NaN
NaN - NaN
NaN / NaN
```

Division by zero produces `Inf`, whose name is reminiscent of "infinity." `Inf` infiltrates any calculation in which it takes part:
```{r warning=FALSE}
3 * Inf
sqrt(Inf)
0 * Inf
Inf + Inf
Inf - Inf
1/Inf
```
::: {.scaffolding}
To see the benefits of the `NaN` / `Inf` system let's plot out the logarithm function over the graphics domain $-5 \leq x \leq 5$. Of course, part of that graphics domain, $-5 \leq x \leq 0$ is not in the domain of the logarithm function and the computer is entitled to give us a slap on the wrists. The `NaN` provides some room for politeness. 

Open a sandbox and see what happens when you make the plot.
```{r eval=FALSE}
slice_plot(log(x) ~ x, domain(x=c(-5,5)))
```
:::

In a purely mathematical sense, the problem with functions being undefined over an extended part of a domain has been handled with cunning and imagination. But the solution---the invention of complex numbers---is not our concern here. Instead, we're going to embrace functions that have a domain smaller than the whole number line and see what we can do with them. 

To illustrate, let's use computer notation to create a function whose domain is $x < 1$. To do this, we need a way to write "if," as in, "If $x$ is 1 or greater, return `NaN`." We'll use a function in R that let's ask a TRUE/FALSE question and, depending on the answer, do one or another calculation. The question-answering R function is `ifelse()` whose name is remarkably descriptive. The `ifelse()` function takes three arguments. The first is the question to be asked, the second is the value to return if the answer is "yes," and the third is the value to return for a "no" answer.

```{r warning=FALSE}
g <- makeFun( ifelse(x < 1, x, NaN) ~ x)
slice_plot(g(x) ~ x, domain(x = c(-2, 2)))
```
What takes getting used to here is the expression `x < 1` which is a ***question*** not a statement of fact. There's no standard traditional mathematical notation for questions, although some people use a question mark as in $x \stackrel{?}{<} 1$.

YOU WERE HERE. PASTE TWO FUNCTIONS TOGETHER

EXAMPLE: We can't produce the ccf vs temperature as a linear combination of straight-line functions: such a linear combination would be just another linear function. We need a piecewise function to do the job.

Consider the data plotted below recording monthly household natural gas use for the author's family. This varies from month to month, and since gas is mainly used for heating the house, it's reasonable to think that gas usage is related to the outdoor temperature. Each dot in the graph shows one month's data, with temperature measured in degrees F and natural gas measured by volume: cubic feet appreviated ccf. A straight-line function has been ***fitted*** to the data.

```{r Fun-1C-abcd-1, echo=FALSE}
gf_point(ccf ~ temp, data = Home_utilities) %>%
  gf_labs(title="Household natural gas use", x = "Average temperature for the month (deg. F)", y = "Volume of gas used (cubic feet)") %>%
  gf_lims(x = c(0, 85)) %>% 
  gf_lm(ccf ~ temp, data = Home_utilities %>% filter(temp < 60))
```

The graph has several features that are not unusual when using data to construct a mathematical model. 

i. The function selected, which gives ccf versus outdoor temperature, is roughly centered on the cloud of data. That is, for a given input value, the function output goes through the vertical center of the data points near that input value.

ii. For part of the domain, the function is a good match to the data.

iii. For another part of the domain, temperatures above about 60 degrees, the function deviates systematically from the data. Indeed, the output of the function is *negative* when temperature is above the mid 60s. (Of course, the *amount* of natural gas used can hardly be negative!)

iv. There are a few data points, near 40 and 60 deg. F that are far from the output of the model at those temperature. Such points are called ***outliers***. One of the uses of mathematical models in interpreting data is to make it easier to spot data records that don't fit an overall pattern. (From the graph itself, one can only speculate about what might be responsible for the outliers. Here it seems to be an error in transcribing the data.)

The straight-line function has two parameters: the ***slope*** and the ***intercept***. Since the domain of the graph includes 0, we can read the intercept directly from the graph: at an input of 0 the function output is roughly 300 ccf.

The slope is, famously, the "rise over run."  Mark off a convenient interval on the domain. We'll use 0 to 64 degrees. Then find the vertical interval of the function output over that interval on the domain. We selected 0 to 64 for the domain since the function output is easy to read: about 300 ccf at 0 deg and 0 ccf at 64 degrees. The amount of "rise" is therefore $0-300$ ccf and the run is $64 - 0$ deg, so the slope is $$\frac{0-300}{64-0} \frac{\text{ccf}}{\text{deg}} \approx -4.6 \frac{\text{ccf}}{\text{deg}}$$ The negative sign on the slope indicates that the function output falls as the input increases.

For a straight-line function, you will find the same slope whatever non-zero interval on the domain you choose for the run. Many other kinds of functions have a slope that differs for different inputs. One of the central ideas of calculus is that even for non-straight-line functions, a meaningful calculation of the ***slope at a single input*** can be constructed. We'll examine that issue carefully later in the course. 

In calculus, the slope of a function is a quantity of particular interest. Here, the slope tells us that a one degree increase in outdoor temperature (averaged over a month) corresponds to a 4.6 ccf *decrease* in natural gas use. 

As you'll see later in the course, the slope of a function is the ***sensitivity*** of the output to a change in the ***input***.

It's often the case that a given model ***accounts*** for only part of the pattern seen in data. There are many synonyms for "accounts": "*captures* only part of the pattern," "*matches* only part of the pattern," and so on. The blue straight-line model in Figure \@ref(fig:Fun-1C-abcd-1) doesn't account for the leveling out of natural gas use for temperatures greater than about 60 degrees. 

Modelers look for such discrepancies between a candidate model (here, the blue line) and the data. Sometimes such discrepancies indicate that the wrong kind of mathematical function has been selected for the model or that the model has not been fitted to the data properly. A skilled modeler will treat the discrepancies as an opportunity to learn more about the real-world system being modeled. With this additional knowledge, a better model can be constructed. 

Those familiar with home heating will know that for temperatures about about 60 degrees F, **no heating is necessary** and fuel use for heating falls to zero. But there are other uses for fuel such as cooking and water heating. To judge from the data, those uses don't depend in any strong or obvious way on outdoor temperature.

---

Exercise: Compare the straight-line model fitted to *all* the ccf data to the model fitted to data where the temperature was less than 60 degrees. Implement as `heating_ccf(temp)`

Exercise: Make a straight-line model for the energy used for cooking and heating.  Implement as `other_ccf(temp)`

Exercise: Piece together the two models to make a more comprehensive model of energy use. Show the computer implementation of this function.

```r
all_ccf <- makeFun(
              ifelse(temp < 60, 
                     heating_ccf(temp) + other_ccf(temp),
                     other_ccf(temp)) ~ temp)
```


**Example: Find day length as a function of latitude. The formula from Fun-assembling can give a day length less than zero or greater than 24 hours. Write a function that takes such out-of-bound answers and replaces them with 0 or 24 as appropriate.**

**Example: ASDR envelope in synthesized music**

<https://en.wikipedia.org/wiki/Envelope_(music)>


**Example: Piecewise functions in machine learning**

**Example: Wind power from wind-speed**

**Example: Heating degree days. Cooling degree days.**
