# Magnitudes {#magnitudes}

Undoubtedly you are comfortable with the standard way of writing numbers, for instance 33 or 512 or 1051. Elementary school students master the comparison of such numbers. Which is greater: 512 or 33? Which is less, 1051 or 512? You can answer such questions at a glance; the comparison can be accomplished simply by counting the number of digits. 1051 has four digits, so it is larger than the three-digit number 512. There are two digits in 33, so it smaller than 512. When two numerals have the same number of digits---say, 337 and 512---you can't answer the "greater than" question by simple counting. Instead, you proceed from left to write and compare the number in each place. So, for 512 and 337, you compare 5 to 3 and ... since 5 is greater than 3, 512 is greater than 337. If the two leading digits are the same, go on to the next digit and so on for all the digits in turn. 

Things were not always this simple. Our number system that uses *place* and *Arabic* numerals is a human invention. An example of an earlier number system is Roman numerals. Here, comparison is hard. For instance, which of these three numbers is bigger?

$$\mbox{MLI or CXII or XXXIII}$$
The typographically shorter number is the largest, and vice versa. Even when two Roman numerals have the same length, it's not trivial to compare them on a place-by-place basis. For instance, IC is about fifteen times bigger than VI, even though I is much smaller than V.

## Counting digits

Digit counting provides an easy, fast way to perform many calculations, at least approximately. What is $\sqrt{10000}$? There are five digits, and the square root of a number will have "half the number of digits." So, $\sqrt{10000} = 100$. What is $10 \times 34$? Easy: 340. Just append the one zero from 10 to the end of 34. What is $1000 \times 13$? Just as easy: 13,000. We even punctuate written numbers with commas and a period in order to facilitate counting digits. 

Imagine having a digit counting function called digit(). It takes a number as input and produces a number as output. We don't have a ***formula*** for digit(), but for some inputs the output can be calculated just be counting. For example:

- digit(10) $\equiv$ 1
- digit(100) $\equiv$ 2
- digit(1000) $\equiv$ 3
- ... and so on ...
- digit(1,000,000) $\equiv$ 6
- ... and on.

The digit() function easily can be applied to the product of two numbers. For instance:

- digit(1000 $\times$ 100) = digit(1000) + digit(100) = 3 + 2 = 5.

Similarly, applying digit() to a ratio gives the difference of the digits of the numerator and denominator, like this:

- digit(1,000,000 $\div$ 100) = digit(1,000,000) - digit(100) = 6 - 2 = 4

## Using digit() to understand magnitude

We haven't shown you the digit() function for anything but the handful of discrete inputs listed above. It was a heroic task to produce the continuous version of digit(). The method is sketched out in \@ref(fractional-digits). 

In practice, digit() is so useful that it could well have been one of our basic modeling functions: 
$$\text{digit(x)} = 2.302585 \ln(x)$$ or, in R, `log10()`. We elected  $\ln()$ rather than digit() for reasons that will be seen when we study ***differentiation***.

::: {.todo}
Human eye and ear
:::


## Quantity and magnitude

The familiar quantity 60 miles-per-hour is written as a number (60 here) followed by units. The quantity is neither the number nor the units: it is the combination of the two. For instance, 100 is obviously not the same as 60. And miles-per-hour is not the same as kilometers-per-hour. Yet, 60 miles-per-hour is almost exactly the same quantity as 100 kilometers-per hour.^[95.69 km/hr is exactly 60 mph.]

6, 60, 600, and 6000 miles-per-hour are quantities that differ in size by ***orders of magnitude***. Such differences often point to a substantial change in context. A jog is 6 mph, a car on a highway goes 60 mpg, a cruising commercial jet goes 600 mph, a rocket passes through 6000 mph on its way to orbital velocity. 

In everyday speech, the difference between 60 and 6 is 54; just subtract. Modelers and scientists routinely mean something else: the difference between 60 and 6 is "one order of magnitude." Similarly, 60 and 6000 are different by "two orders of magnitude," and 6 and 6000 by three orders of magnitude. 

In everyday English, we have phrases like "a completely different situation" or "different in kind" or "qua**l**itatively different" (note the **l**) to indicate substantial differences. "Different orders of magnitude" expresses the same kind of idea but with specific reference to quantity. 

The use of factors of 10 in counting orders of magnitude is arbitrary. A person walking and a person jogging are on the edge of being qualitatively different, although their speeds differ by a factor of only 2. Aircraft that cruise at 600 mph and 1200 mph are qualitatively different in design, although the speeds are only a factor of 2 apart. A professional basketball player (height 2 meters or more) is qualitatively different from a third grader (height about 1 meter).

Modelers develop an intuitive sense for when to think about difference in terms of a subtractive difference (e.g. 60 - 6 = 54) and when to look at orders of magnitude (e.g. 60-to-6 is one order of magnitude). This seems to be a skill based in experience and judgment, as opposed to a mechanical process. 

One clue that thinking in terms of orders of magnitude is appropriate is when you are working with a set of objects whose range of sizes spans one or many factors of 2. Comparing baseball and basketball players? Probably no need for orders of magnitudes. Comparing infants, children, and adults in terms of height or weight? Orders of magnitude may be useful. Comparing bicycles? Mostly they fit within a range of 2 in terms of size, weight, and speed (but not expense!). Comparing cars, SUVs, and trucks? Differences by a factor of 2 are routine, so thinking in terms of order of magnitude is likely to be appropriate.

Another clue is whether "zero" means "nothing." Daily temperatures in the winter are often near "zero" on the Fahrenheit or Celcius scales, but that in no way means there is a complete absence of heat. Those scales are arbitrary. Another way to think about this clue is whether ***negative values*** are meaningful. If so, thinking in terms of orders of magnitude is not likely to be useful.

You may have guessed that `digits()` is handy for computing differences in terms of orders of magnitude. Here's how:

1. Make sure that the quantities are expressed in the same ***units***. 
2. Calculate the difference between the `digits()` of the numerical part of the quantity.

::: {.workedexample}
What is the order-of-magnitude difference in velocity between a snail and a walking human. A snail slides at about 1 mm/sec, a human walks at about 5 km per hour. Putting human speed in the same units as snail speed: 
$$5 \frac{km}{hr} = \left[\frac{1}{3600} \frac{hr}{sec}\right] 5 \frac{km}{hr} = \left[10^6 \frac{mm}{km}\right] \left[\frac{1}{3600} \frac{hr}{sec}\right] 5 \frac{km}{hr} = 1390 \frac{mm}{sec} $$
Calculating the difference in `digits()` between 1 and 1390:
```{r}
log10(1390) - log10(1)
```
So, about 3 orders of magnitude difference in speed. To a snail, we walking humans must seem like rockets on their way to orbit!
:::

::: {.intheworld}
Animals, including humans, go about the world in varying states of illumination, from the bright sunlight of high noon to the dim shadows of a half moon. To be able to see in such diverse conditions, the eye needs to respond to light intensity across many orders of magnitude. 

The ***lux*** is the unit of illuminance in the Syst√®me international. This table^[Source: <https://en.wikipedia.org/wiki/Daylight>] shows the illumination in a range of familiar outdoor settings:

Illuminance | Condition
------------|---------------
110,000 lux | Bright sunlight
20,000 lux	| Shade illuminated by entire clear blue sky, midday
1,000 lux	| Typical overcast day, midday
400 lux	| Sunrise or sunset on a clear day (ambient illumination)
0.25 lux |	A full Moon, clear night sky
0.01 lux | 	A quarter Moon, clear night sky

For a creature active both night and day, they eye needs to be sensitive over 7 orders of magnitude of illumination. To accomplish this, eyes use several mechanisms: contraction or dilation of the pupil accounts for about 1 order of magnitude, photopic (color, cones) versus scotopic (black-and-white, rods, nighttime) covers about 3 orders of magnitude, adaptation over minutes (1 order), squinting (1 order).

:::



## Composing $\ln()$ 

The logarithm is the inverse of the exponential function. In other words, $$\ln(e^x) = x\ \ \text{and}\ \ e^{\ln(x)} = x$$

Think about this in terms of the kinds of quantities that are the input and output to each function.

* Logarithm: The input is a quantity, the output is the magnitude of that quantity.
* Exponential: The input is a magnitude, the output is the quantity with that magnitude.

```{exercise, name="cat-lend-futon"}
```
<details>`r knitr::knit_child("Exercises/Fun/cat-lend-futon.Rmd")`</details>

```{exercise, name="Boyles-data.Rmd"}
```
<details>`r knitr::knit_child(exercise_file("06", "Boyles-data.Rmd"))`</details>

## Magnitude graphics



:::

```{exercise, name="mag-blue"}
```
<details>`r knitr::knit_child("Exercises/Fun/mag-blue.Rmd")`</details>


::: {.todo}
Derive straight-line form of power-law function

Suppose $f(x) = A x^p$. The $\ln(f(x)) = p \ln(x) + \ln(A)$. 

```{r}
f <- makeFun(A  * x^p ~ x, A=1, p=2.5)
Pts <- tibble::tibble(
  x = seq(1, 50, length=10),
  y = f(x),
  color = rainbow(length(x))
)

P <- slice_plot(f(x) ~ x, domain(x=c(0,50))) %>%
  gf_point(y ~ x, color=~color, data = Pts) %>%
  gf_refine(scale_color_identity())
P
P %>%
  gf_refine(scale_y_log10(), scale_x_log10())
```

:::


```{exercise, name="engine-magnitude-new"}
```
<details>`r knitr::knit_child("Exercises/Fun/engine-magnitude-new.Rmd")`</details>


## Magnitude scales

Plotting the logarithm of a quantity gives a visual display of the magnitude of the quantity and labels the axis as that magnitude. A useful graphical technique is to label the axis with the original quantity, letting the position on the axis show the magnitude.

To illustrate, Figure \@ref(fig:mag-scales-1)(left) is a log-log graph of horsepower versus displacement for the internal combustion engines reported in the `Engines` data frame. The points are admirably evenly spaced, but it is hard to translate the scales to the physical quantity. The right panel in Figure \@ref(fig:mag-scales) shows *exactly the same data points*, but now the scales are labeled using the original quantity.

```{r mag-scales-1, out.width="50%", fig.show="hold"}
gf_point(log(BHP) ~ log(displacement), data = Engines)
gf_point(BHP ~ displacement, data = Engines) %>%
  gf_refine(scale_y_log10(), scale_x_log10()) 

```

The tick marks on the vertical axis in the left pane are labeled for 0, 2.5, 5.0, 7.5, and 10. That doesn't refer to the horsepower itself, but to the logarithm of the horsepower. The right pane has tick labels that are in horsepower at positions marked 1, 10, 100, 1000, 10000.  

Such even splits of a 0-100 scale are not appropriate for logarithmic scales. One reason is that 0 cannot be on a logarithmic scale in the first place since $\log(0) = -\infty$.

Another reason is that 1, 3, and 10 are pretty close to an even split of a logarithmic scale running from  1 to 10. It's something like this:

```
1              2            3          5            10     x
|----------------------------------------------------|
0               1/3         1/2        7/10          1     log(x)
```

It's nice to have the labels show round numbers. It's also nice for them to be evenly spaced along the axis. The 1-2-3-5-10 convention is a good compromise; almost evenly separated in space yet showing simple round numbers.

```{exercise, name="fish-walk-green"}
```
<details>`r knitr::knit_child("Exercises/Fun/fish-walk-green.Rmd")`</details>


```{exercise,name="tiger-have-fork"}
```
<details>`r knitr::knit_child(exercise_file("06", "tiger-have-fork.Rmd"))`</details>

## Fractional digits (optional) {#fractional-digits}

So far, we have the digit() function in a tabular form:

input | output
----|-----------
$\vdots$ | $\vdots$
0.01 | -2
0.1 | -1
1   | 0
10   | 1
100 | 2
1000 | 3
10,000 | 4
100,000 | 5
1,000,000 | 6
$\vdots$ | $\vdots$

Here's the point-plot presentation of the table:

```{r log-1st-try, echo=FALSE, fig.cap = "Connecting the data points for the digit function to make a continuous function."}
L10 <- tibble::tribble(
  ~ input, ~ output,
  0.01, -2,
  0.1, -1,
  1, 0,
  10, 1,
  100, 2,
  1000, 3,
  10000, 4,
  100000, 5,
  1000000, 6
) 
ticks <- c(1,10,100,10000,50000,
           100000,200000,500000,750000, 1000000)
gf_point(output ~ input, data = L10) %>%
  gf_labs(title = "The digit function") %>%
  gf_refine(scale_x_sqrt(breaks=ticks, 
                         labels=format(ticks, scientific=FALSE, big.mark=","))) %>%
  gf_line()
```
We've imagined digits() to be a continuous function so we've connected the gaps with a straight line. Now we have a function that has an output for any input between 0.01 and 1,000,000, for instance, 500,000.

The angles between consecutive line segments give the function plotted in Figure \@ref(fig:log-1st-try) an unnatural look. Still, it is a continuous function with an output for any input even if that input is not listed in the table.

Starting around 1600, two (now famous) mathematicians, [John Napier](https://en.wikipedia.org/wiki/Henry_Briggs_(mathematician)) (1550-1617) and [Henry Briggs](https://en.wikipedia.org/wiki/Henry_Briggs_(mathematician)) (1561-1630) had an idea for filling in gaps in the table. They saw the pattern that for any of the numbers $a$ and $b$ in the input column of the table
$$ \text{digit}(a \times b) = \text{digit}(a) + \text{digit}(b)$$
This is true even when $a=b$. For instance, digit(10)=1 and digit(10$\times$ 10) = 2.

Consider the question what is digit(316.2278)? That seems a odd question unless you realize that $316.2278 \times 316.2278 = 100,000$. Since digit(100000) = 5, it must be that digit(316.2278) = 5/2.

Another question: what is digit(17.7828)? This seems crazy, until you notice that $17.7828^2 = 316.2278$. So digit(17.78279) = 5/4.

It happens that for a couple of thousand years mathematicians have known how to compute the square root of any number to a high precision. By taking square roots and dividing by two, it's easy to fill in more rows in the digit()-function table. You get even more rows by noticing other simple patterns like $$\text{digit}(a/10) = \text{digit}(a) -1  \ \ \and \ \ \ \text{digit}(10 a) = \text{digit}(a) + 1$$

Here are some additional rows in the table

input | output | Why?
------|--------|------
316.2278 | 2.5 | From $\sqrt{\strut100,000}$
17.17828 | 1.25 | From $\sqrt{\strut 316.2278}$
4.21696 | 0.625 | From $\sqrt{\strut 17.17828}$
31.62278 | 1.5  | From 316.2278/10
3.162279 | 0.5 | From 31.62278/10

```{r echo=FALSE}
# Just to compute the timing statement in the next paragraph.
#remotes::install_github("collectivemedia/tictoc")
#library(tictoc)
#tic()
start <- tibble::tibble(input = 10^{-5:6}, output = -5:6)
for (k in 1:6) {
  root <- start %>% 
    mutate(input = sqrt(input), output = output/2)
  root2 <- start %>%
    mutate(input = sqrt(sqrt(input)), output = output/4)
  root3 <- start %>%
    mutate(input = sqrt(sqrt(sqrt(input))), output = output/8)
  square <- start %>%
    mutate(input = input^2, output = 2*output)
  cube <- start %>%
    mutate(input = input^3, output = 3*output)
  tenths <- start %>%
    mutate(input = input/10, output = output - 1)
  tens <- start %>%
    mutate(input = input*10, output = output + 1)
  start <- rbind(start, root, root2, root3, square, cube, tenths, tens) %>% unique() %>% 
    arrange(input)
}
#toc()
```

You can play this game for weeks. We asked the computer to play the game for about half a second and expanded the original digit() table to `r nrow(start %>% filter(output >= -2, output <= 6))` rows.

Figure \@ref(fig:expanded-log) plots the expanded digits() function table.

```{r expanded-log, echo=FALSE}
ticks <- 1:10

gf_point(output ~ input, 
         data = start %>% filter(output <= 1, output >= 0)) %>%
  gf_labs(title = "The digit function with more entries") %>%
  gf_refine(scale_x_continuous(breaks=ticks)) %>%
  gf_line()
```
Now we have a smooth function that plays by the digit rules of multiplication.

Henry Briggs and his assistants did a similar calculation by hand. Their work was published in 1617 as a table. 

```{r briggs-first-page, echo=FALSE, out.width="100%", fig.cap="Part of the first page of Henry Briggs table of logarithms", fig.align="center"}
knitr::include_graphics(normalizePath("www/Briggs-starttable.png"))
```

The table was called the *Chilias prima*, Latin for "First group of one thousand." True to its name, the table gives the output of digits() for the inputs 1, 2, 3, ..., 998, 999, 1000. For instance, as you can see from the top row of the right-most column, digits(67) = 1.82607480270082. 

In everyday speech, 67 has two digits. The authors of *Chilias prima* sensibly didn't use the name "digit()" for the function. They chose something more abstract: "logarithm()". Nowadays, this function is named $\log_{10}()$. In R, the function is called `log10()`.

```{r}
log10(67)
```

Our main use for $\log_{10}()$/`log10()` will be to count digits in order to quickly compare the magnitude of numbers. The difference digits($x$) - digits($y$) tells how many factors of 10 separate the magnitude of the $x$ and $y$.

Another important logarithmic/digit-counting function is $\log_2()$, written `log2()` in R. This counts how many ***binary digits** are in a number. For us, $\log_2(x)$ tells how many times we need to double, starting at 1, in order to reach $x$. For instance, $\log_2(67) = 6.06609$, which indicates that $67 = 2\times 2 \times 2 \times 2 \times 2 \times 2 \times 2^{0.06609}$

$\log_2(x)$ and $\log_{10}(x)$ are proportional to one another. One way to think of this is that they both count "digits" but report the results in different units, much as you might report a temperature in either Celsius or Fahrenheit. For $\log_2(x)$ the units of output are in ***bits***. For $\log_{10}(x)$ the output is in ***decades***.

A third version of the logarithm function is called the ***natural logarithm*** and is denoted $\ln()$ in math notation and simply `log()` in R. We'll need additional calculus concepts before we can understand what justifies calling $\ln()$ "natural."

EXERCISE: Compute $10^y$ to convert a "number of digits" into the number whose digits are being counted. For instance, $10^2.5$ is 316.228. 

EXERCISE: How many binary digits in 64? in 127? 

EXERCISE: $\log_{10}(x)$ and $\log_2(x)$ are proportional to one another. What's the constant of proportionality? 


