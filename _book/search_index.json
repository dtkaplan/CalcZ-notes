[["index.html", "CalcZ Student Notes Status", " CalcZ Student Notes Daniel Kaplan 2021-05-14 Status This is the working version for Summer 2021. "],["what-is-a-function.html", "Chapter 1 What is a function?", " Chapter 1 What is a function? [F-10] Objective Original: Understand the relationship between inputs and outputs for functions of one or two input variables, to include functions defined piecewise*. Objective Revised: Recognize that functions are a way of representing (storing) what we know and be able to use properly the basic nomenclature of functions)* People have many ways of organizing what they know. Often we rely on our intuitive abilities of memory, but we also have constructed frameworks to make the storage more accessible and reliable. One of these frameworks is the table, generally set up as an array of rows and columns. For instance, here is a table about a range of internal combustion engines of various sizes: DT::datatable(Engines) Each row of the table reports on one, specific engine. Each column is one attribute of the of an engine. Using such tables can be easy. For example, if asked to report how fast the engine named “Enya 60-4C” spins, you would go down to the Enya 60-4C row and over to the “RPM” column and read off the answer: 11,800 revolutions per minute (RPM). A table like this can be said to describe as raw numbers the general relationships between various engine attributes. For instance, we might want to understand the relationship (if any) between RPM and engine mass, or relate the number and diameter (that is, “bore”) and depth (that is, “stroke”) of the cylinders to the power generated by the engine. Any single entry in the table doesn’t tell us about such general relationships; we need to consider the rows and columns as a whole. If you examined the relationship between engine power and cylinder number, diameter, and depth, you will find that (as a rule) the larger the number, diameter, and depth, the more powerful the engine. That’s a qualitative description of the relationship. Most educated people are able to understand such a quantitative description. Even if they don’t know exactly what “power” means, they have some rough conception of it. And almost everyone knows what diameter, depth, and number mean. Often, we’re interested in having a quantitative description of a relationship such as the one (number, diameter, depth) \\(\\rightarrow\\) power. Remarkably, the many of educated people are uncomfortable with the idea of using quantitative descriptions of a relationship: what sort of language the description should be written with; how to perform the calculations to use the description; how to translate between data (such as in the table) and a quantitative description; how to translate the quantitative description to address a particular question or make a decision. This course is about constructing and using such quantitative descriptions, which we’ll call mathematical models. Skills for doing this are essential for work in engineering and science, and highly valued in many other fields in commerce, management, and government. Often, the work of applying such quantitative skills is called calculation. The name calculus is used to describe the methods that are widely used for undertaking calculations. Functions are a fundamental way of organizing mathematical models and calculations. You have undoubtedly seen them in your previous mathematics education, but it’s worth reviewing them from the basics so that we can share a vocabulary for communicating about them. A function is a transformation from one or more inputs to an output. To keep things simple for now we’ll focus on inputs and outputs that are numeric, but later we’ll need a more nuanced view of “numeric” that takes into account the different kinds of things that are represented by numbers, e.g. length, power, RPM. To see how functions work, imagine a long corridor with a sequence of offices, each identified by a room number. The input to the function is the room number. To evaluate the function for that input, you knock on the appropriate door and, in response, you’ll receive a piece of paper with a number to take away with you. That number is the output of the function. This will sound at first too simple to be true, but … In a mathematical function each office gives out exactly the same number every time someone knocks on the door. Obviously, being a worker in such an office is highly tedious and requires no special skill. Every time someone knocks on the worker’s door, he or she writes down the same number on a piece of paper and hands it to the person knocking. What that person will do with the number is of absolutely no concern to the office worker. The utility of such functions depends on the artistry and insight of the person who creates them: the modeler. An important point of this course is to teach you some of that artistry. Hopefully you will learn through that artistry to translate your insight to the creation of functions that are useful in your own work. But even if you just use functions created by others, knowing how functions are built will be helpful in using them properly. In the sort of function just described, all the offices were along a single corridor. Such functions are said to have one input, or, equivalently, to be functions of one variable. To operate the function, you just need one number: the address of the office from which you’ll collect the output. Many functions have more than one input: two, three, four, … tens, hundreds, thousands, millions, …. In this course, we’ll work mainly with functions of two inputs, but the skills you develop will be applicable to functions of more than two inputs. What does a function of two inputs look like in our office metaphor? Imagine that the office building has many parallel corridors, each with a numeric ID. To evaluate the function, you need two numeric inputs: the number of the corridor and the number of the door along that corridor. With those two numbers in hand, you locate the appropriate door, knock on it and receive the output number in return. Three inputs? Think of a building with many floors, each floor having many parallel corridors, each corridor having many offices in sequence. Now you need three numbers to identify a particular office: floor, corridor, and door. Four inputs? A street with many three-input functions along it. Five inputs? A city with many parallel four-input streets. And on and on. Applying inputs to a function in order to receive an output is only a small part of most calculations. Calculations are usually organized as algorithms, which is just to say that algorithms are descriptions of a calculation. The calculation itself is … a function! How does the calculation work? Think of it as a business. People come to your business with one or more inputs. You take the inputs and, following a carefully designed protocol, hand them out to your staff, perhaps duplicating some or doing some simple arithmetic with them to create a new number. Thus equipped with the relevant numbers, each member of staff goes off to evaluate a particular function with those numbers. (That is, the staff member goes to the appropriate street, building, floor, corridor, and door, returning with the number provided at that office.) The staff re-assembles at your roadside stand, you do some sorting out of the numbers they have returned with, again following a strict protocol. Perhaps you combine the new numbers with the ones you were originally given as inputs. In any event, you send your staff out with their new instructions—each person’s instructions consist simply of a set of inputs which they head out to evaluate and return to you. At some point, perhaps after many such cycles, perhaps after just one, you are able to combine the numbers that you’ve assembled into a single result: a number that you return to the person who came to your business in the first place. A calculation might involve just one function evaluation, or involve a chain of them that sends workers buzzing around the city and visiting other businesses that in turn activate their own staff who add to the urban tumult. As you know, there is a powerful way of thinking about numbers in terms of space and geometry. For instance, a single number corresponds to a point on a line: the so-called number line. A pair of inputs, say, (x, y) corresponds to a point in a plane, often called the Cartesian coordinate plane. Three numbers corresponds to a point in space, perhaps organized into (x, y, z) of a Cartesian space. There are higher-dimensional spaces, but usually special training is needed to become comfortable with them. If you are having this discomfort, you might prefer to work with the office metaphor. Just for fun, here’s how you can think of a 10-dimensional space: 10 numbers, one telling you which planet, the next specifying the continent on that planet, and so on for country, state, city, street, building, floor, corridor, door. The set of inputs with which the function can be evaluated is called the domain of the function. Sometimes we describe the domain as a space, e.g. the number line, the plane, and so on. Sometimes domains including more restrictions. For instance, a particular input might only meaningfully be positive, with no offices corresponding to negative values for that input. Or, an input might be restricted to be in the interval 0 to 1. Sometimes in calculus, the domain excludes an isolated point. For instance, there may be no office at the door marked 0 but the neighboring doors open into working offices. The range of a function is the set of all the outputs that can be produced. Since at this stage we’re working only with functions that return a single number as output, it’s common to describe the range as all or part of the number line. For instance, some functions only have positive outputs. Other functions’ outputs are always in the interval 0 to 1. (This is the case, for instance, when the function returns a probability as the output.) Weather forecasting by numerical process Weather forecasting by numerical process is a highly influential book, from 1922, by Lewis Fry Richardson. He envisioned a calculation for a weather forecast as a kind of function. The domain for the forecast is the latitude and longitude of a point on the globe, rather than the rectilinear organization of corridor. One fantastic illustration of the idea shows a building constructed in the form of an inside-out globe. At each of many points on the globe, there is a business. (You can see this most clearly in the foreground, which shows several boxes of workers.) Figure 1.1: An artist’s depiction of the organization of calculations for weather forecasting by Richardson’s system. Source Each business might work this way: In each business there is a person who will report the current air pressure at that point on the globe, another person who reports the temperature, another reporting humidity, and so on. To compute the predicted weather for the next day, the business has a staff assigned to visit the neighboring businesses to find out the pressure, temperature, humidity, etc. Still other staffers take the collected output from the neighbors and carry out the arithmetic to translate those outputs into the forecast for tomorrow. For instance, knowing the pressure at neighboring points enables the direction of wind to be calculated, thus the humidity and temperature of air coming in to and out of the region the business handles. In today’s numerical weather prediction models, the globe is divided very finely by latitude, longitude, and altitude, and software handles both the storage of present conditions and the calculation from that of the future a few minutes later. Repeating the process using the forecast enables a prediction to be made for a few minutes after that, and so on. Some of the most important concepts in calculus relate to the process of collecting outputs from neighboring points and combining them: for instance finding the difference or the sum. To illustrate, here is the first set of equations from Richardson’s Weather forecasting …, writen in the notation of calculus: You can hardly be expected at this point to understand the calculations described by these equations, which involve the physics of air flow, the coriolis force, etc. but it’s worth pointing out some of the notation: The equations are about the momentum of a column of air at a particular latitude (\\(\\phi\\)) and longitude. \\(M_E\\) and \\(M_N\\) are east-west and north-south components of that momentum. \\(\\partial M_E /\\partial t\\) is the amount the east-west momentum will change in the next small interval of time (\\(\\partial t\\)). \\(p_G\\) is the air pressure at ground level from that column of air. \\(\\partial p_G / \\partial n\\) is about the difference between air pressure in the column of air and the columns to the north and south. Calculus provides both the notation for describing the physics of climate and the means to translate this physics into arithmetic calculation. "],["graphs-graphics.html", "Chapter 2 Graphs &amp; Graphics 2.1 The mathematical graph 2.2 Contour plots 2.3 Slice plots", " Chapter 2 Graphs &amp; Graphics 2.1 The mathematical graph [F-20] Understand that a mathematical graph consists of points in a composite space: the input $ imes$ output. Needless to say, we won’t be implementing functions by building cities of multi-floor office buildings. Instead, we’ll have a variety of implementations that take different forms. We’ll start with two: Graphs: a form of representation that lets you evaluate a function by eye. Formulas: another form of representation that gives the instructions for evaluating a function using arithmetic (and other functions). Scientific and statistical graphics are visual depictions of information and data. Mathematicians favor a particular style of graphics for representing functions with one or two inputs. This favored style is called a function graph, which has a specific technical meaning in mathematics. In a function graph, the frame—a region on a piece of paper or other display—is a coordinate grid. Every position on the grid is represented by both the inputs to the function and the output from the function. For instance, for a function with one input, the frame is often the Cartesian coordinate plane, like this: This graphics frame is not yet a mathematical graph. It’s merely the field on which the graph will be drawn. One axis represents the input to the function. The other axis represents the output from the function. The graph shows the output for each individual input. That is, it is a series of points marking the level of the output for each given input. In our office metaphor for functions, the input is the number on the office door. But here the door numbers are not just integers (like 2) but any number on the number line (like 2.718282). So the points marked form a continuous curve, like this: You can easily evaluate a function for a given input from its graph. As you know, just put your finger at the horizontal coordinate for the input. Then move your finger upward to reach the point on the curve directly above that horizontal coordinate. You read off the value of the function at that input by reference to the scale on the vertical axis. Graphs are relatively modern, coming into mainstream use only in the 1700s. Much of mathematics was developed before graphs were invented. One consequence of this is that function tasks that are easy using a graph might be very hard with the previous ways of implementing functions. This is analogous to the way that arithmetic is pretty easy with Arabic numerals, but really hard with Roman numerals. It’s not possible to show with a graph the whole of a function whose domain is \\(-\\infty\\) to \\(\\infty\\). Consequently, when drawing a graph we choose to show only that part of the domain that we expect will be relevant to our needs. Sometimes, the graphic’s domain includes parts that are not in the domain of the function being drawn. In such cases, the function’s graph does not extend into the invalid part of the graphic domain, as in this plot of a function whose domain is only the positive numbers. ## Warning in log(x): NaNs produced ## Warning: Removed 252 row(s) containing missing values (geom_path). This function has a range that runs from \\(-\\infty\\) to \\(\\infty\\), but the limits of paper and display mean that we can show only part of this range. With experience, you’ll learn to read the hints in a graph that the underlying function might have a range larger than the one shown in the graphic. We can also draw graphs of functions with two inputs. Now the points need to be marked in a 3-dimensional space: one axis for each of the two inputs and another axis for the output. Like this: Figure 2.1: (Figure Fun-1b-1.2) It is very hard to read a graph of a function with two inputs. Think of the graph as a kind of tent suspended over a domain of ground. The graph itself is a surface. To show the graph on a display, some tricks of the trade are used: color to give an additional scale for the output; computer graphics to let us rotate the surface to look at it from various perspectives, added grid lines and marks on the surface to help us read out the numerical value. 2.2 Contour plots [F-21] Interpret a contour plot of a function of two input variables, to include estimating function values and locations of peaks and valleys. A mathematical graph is just one way to draw a picture of a function with two inputs. There are other ways. One helpful mode of picture is called a contour plot, familiar to many non-mathematicians in the form of topgraphical maps showing landscape elevation as a function of latitude and longitude. Here’s a contour plot of the same function shown in the previous graph: Figure 2.2: (Fig-1b-2.1) This contour plot is a topographical map of the mathematical graph in Figure Figure (Fun-1b-1.2) It may take some practice to learn to read contour plots fluently but it is a skill that’s worthwhile to have. Note that the graphics frame is the Cartesian space of the two inputs. The output is presented as contour lines. Each contour line has a label giving the numerical value of the function output. Each of the input value pairs on a given contour line corresponds to an output at the level labeling that contour line. To find the output for an input pair that is not on a contour line, you interpolate between the contours on either side of that point. For example, the input pair (0, 0)—which is at the bottom of the frame, midway from left to right—falls between the contours labeled “20” and “22.” This means that the output corresponding to input (0, 0) is somewhere between 20 and 22. The point is much closer to the contour labeled “20,” so it’s reasonable to see the output value as 20.5. This is, of course, an approximation, but that’s the nature of reading numbers off of graphs. Often, the specific numerical value at a point is not of primary interest. Instead, we may be interested in how steep the function is at a point, which is indicated by the spacing between contours. When contours are closely spaced, the hillside is steep. Where contours are far apart, the hillside is not steep, perhaps even flat. Another common task for interpreting contour plots is to locate the input pair that’s at a local high point or low point: the top of a hill or the bottom of a hollow. Such points are called local argmax or local argmin respectively. The output of the function at a local argmax is called the local maximum; similarly for a local argmin, where the output is called a local minimum. (The word “argmax” is a contraction of “argument of the maximum.” We will tend to use the word “input” instead of “argument,” but it means exactly the same thing to say “the inputs to a function” as to says “the arguments of a function.”) Still other common tasks for reading contour plots are to start at a given input pair and figure out 1) the direction to move which is most steeply uphill, or 2) the direction to move which will keep the function output the same. It can be helpful to look at a contour map and interpret the contours as representing geographical features: hills, valleys, crests, coves, hollows, and so on. Then, for (Fun-1c) translate between a contour plot and a graph of a function with one input. (We can think about this as a function of two inputs, where we hold one of the inputs constant, that is, always the same. ) 2.3 Slice plots [F-23] Know what is meant by a slice of function of two variables. Be able to determine if a function is increasing, decreasing, or constant when moving horizontally or vertically on the contour plot. As mentioned before, mathematical modeling is the process of constructing mathematical representations of situations or phenomena of interest. In CalcZ, we are primarily interested in using functions as such representations. Almost always, when mathematically modeling a real-world situation or phenomenon, we do not try to capture every nuance of every relationship that might exist in the real world. We leave some things out. Such simplifications make modeling problems tractable and encourage us to identify the most important features of the most important relationships. On the other hand, it’s easy to go wrong and leave out something that’s important. To mitigate this risk, many modeling projects involve a modeling cycle where we propose a candidate model, examine the consequence of that model to see if it corresponds well to the parts of reality that are important to us in our task, and modify the model as needed to produce a new and better candidate. In this spirit, it’s useful always to assume that our models are leaving something out and that a more complete model involves a function with more inputs than the present candidate. The present candidate model should be considered as a slice of a more complete model. Our slice leaves out one or more of the variables in a more complete model. To illustrate this, suppose that we have a “more complete model” in the form of a function of two inputs, as shown in the contour plot below. As you become practiced reading contour plots, you might prefer to read this one as a hilltop (shaded yellow) side-by-side with a hollow or bowl (shaded purple), with green, almost level flanks at the left and right edges of the frame. The most common forms of slice involve constructing a simpler function that has one input but not the other. For example, our simpler function might ignore input #2. There are different ways of collapsing the function of two inputs into a function of one input. An especially useful way in calculus is to take the two-input function and set one of the inputs to a constant value. For instance, suppose we set input #2 to the constant value 1.5. This means that we can consider any value of input #1, but input #2 has been replaced by 1.5. In Figure Fig-1c.2, we’ve marked in red the points in the contour plot that give the output of the simplified function. Each point along the red line corresponds to a specific value of input #1. From the contours, we can read the output corresponding to each of those values of input #1. This relationship, output versus input #1 can be drawn as a mathematical graph (to the right of the contour plot). Study that graph until you can see how the rising and falling parts of the graph correspond to the contours being crossed by the red line. Slices can be taken in any direction or even along a curved path! The blue line below the slice constructed by letting input #2 vary and holding input #1 and the constant value 0. "],["notation-for-functions.html", "Chapter 3 Notation for functions", " Chapter 3 Notation for functions ::: {.objectives data-latex=\"“} state_objective(”F-30“,”Identify the structure of function notation when the function is defined by a formula.\") ::: A graphic such as a contour plot or a mathematical graph can be an excellent way of presenting a function to a human viewer. There are other ways of presenting functions that have other advantages, such as speed of evaluation, computer readability, and the ability to perform computations that ***derive a new function from the original***. If you have studied calculus before, you know the word &quot;derivative,&quot; which is all about a particular kind of new function created from an original. We&#39;ll get to this in good time along with other ways of &quot;deriving&quot; new functions from old. Let&#39;s look carefully at some formats for organizing the parts of a function. Consider the function $$g(x) \\equiv m x + b$$ You already know: i. $g()$ is the name we&#39;ve given to the function. The name is the choice of the modeler. ii. $(x)$ indicates that there is one input to $g()$ and that we are going to call this input &quot;$x$&quot;. a. The parentheses are simply punctuation. b. If we wanted a function with two inputs, we would need two different names inside the parentheses and would separate them with a comma: e.g. $h(x, y) = a_0 + a_x x + a_y y$. iii. $m x + b$ is a ***formula*** in traditional mathematical notation. So is $a_0 + a_x x + a_y y$. a. Note that there is no equal sign in a formula; a formula is **not** an equation! b. The formulas we&#39;ve seen so far can be evaluated with arithmetic. But often a formula will involve the invocation of another function. For example: $\\sqrt{\\strut m x + b}$ or $\\sin(m x) + \\ln(b)$. It&#39;s helpful to generalize the idea of a formula a bit. An ***algorithm*** is a set of instructions for performing a computation. High-school math typically involves presenting algorithms as formula. You learned, maybe in middle school, how to follow the arithmetic steps involved in algorithms described as formulas. You also have likely used a calculator to perform some of the arithmetic or to evaluate functions such as $\\sin()$ and $\\ln()$ and $\\sqrt{\\strut}$ for which you don&#39;t know how to evaluate using simple arithmetic. The calculator is implementing an algorithm with which its been programmed to enable the calculation of $\\sin()$ and $\\ln()$ and such. Many functions are described by algorithms that use concepts common in computer programming but unknown to traditional mathematical notation. Some of these have names like ***iteration*** or ***branching*** and many refer to stored lists of fixed numbers (like the office workers in the street, building, floor, corridor, door image of a function). We&#39;ll deal with some of these things later, but for now ... &gt; We are going to use the word ***algorithm*** to name the kind of expression to the right of $\\equiv$ in a function definition. A ***formula*** is a specific kind of algorithm generally written in traditional math notation. Algorithms, including the ones that are formulas, are written in terms of a set of ***symbols*** that stand for inputs. This is a high-fallutin&#39; way of saying something simple: in $mx + b$, the $x$, $m$, and $b$ are the names we give to the quantities being used in the calculation. The notation we are using for function definition lists some of these names in two places, and others in only one place. Again, look at $$g(x) \\equiv m x + b$$ The $x$ appears both in the algorithm and the list of input name $(x)$ to the left of $\\equiv$. The $m$ and $b$ are different; they appear **only** in the algorithm. The word for such quantities in mathematics is ***parameter***. Eventually, when the algorithm is followed, we&#39;re going to have to put in specific numerical values in place of each parameter. **Where will these parameter values come from?** This is a subject on which mathematical notation is silent. You have to figure it out from context and experience. This is potentially very confusing, especially when a human is not around to sort things out. Fortunately, the notation used in computer programming does not have this flaw. Depending on the language things can be handled in one way or another. For experienced computer programmers: This is the issue of ***scope***. In the software used in CalcZ (R, with the `mosaic` package of extensions), we will take a simple-to-use approach that avoids your having to deal with scope. It works like this: &gt; All modeling functions we construct with R/`mosaic` will list parameters formally as ***arguments*** to the function. It is as if we wrote in traditional notation $$g(x, m, b) \\equiv m x + b$$ There is also a way to give default numerical values to parameters so that you can write $g(3.5)$ and the computer will know where to find the parameter values. In writing about formulas using math notation, we&#39;ll extend the traditional notation to write, for instance, $g(x, m=2, b=3) \\equiv m x + b$. In R/`mosaic`, we would construct a mathematical function like $g()$ using the `makeFun()` function: ```r g &lt;- makeFun(m*x + b ~ x, m=2, b=3) You could also write g &lt;- makeFun(m*x + b ~ x) but this notation means that you will have to give specific numerical values for the m and b inputs whenever you evaluate g(). There won’t be any default values for the “parameters-as-inputs” m and b. Relevant Blog post: CalculusBlog/post-formal-arguments.Rmd [F-31-R] Identify and create R versions of mathematical functions using makeFun() and tilde expressions. [F-32-R] Use the slice_plot(), contour_plot(), and domain() functions in R/mosaic. NOTHING HERE YET ::: {.objectives data-latex=\"\"} [F-33] Master the conventions used in CalcZ for giving names to functions and for referring to functions with “pronouns.” We’re going to be using a lot of functions in CalcZ. Some of these functions have proper names, usually written using short sequences of letters: for instance \\(\\sin()\\), \\(\\ln()\\), \\(\\exp()\\). Other functions will needed just for a sentence or a paragraph or a section, perhaps being used in an example or to lay out the steps of an algorithm. In natural languages such as English, we often use pronouns for such purposes: she, he, it, they, we, I, …. We also will use pronouns for identifying functions. Our policy is this: A pronoun for a function will be named \\(f()\\) or \\(g()\\) or \\(h()\\) or the corresponding upper-case letters \\(F()\\), \\(G()\\), or \\(H()\\). The particular choice of letter f, g, or h has no significance whatsoever. It is just a way to give an unambiguous handle for a function that we are going to be using for a little while. On occasion, we will use subscripts or superscripts on these pronoun letters, for instance \\(f_1()\\) or \\(g^\\star()\\). This is a way to give us many more possible pronouns when we need them. Perhaps this is analogous to words like “sister,” “parent,” “husband,” “cousin,” etc. that allow us to refer, without a proper name, to a specific person. On other occasions, where a function relates to a specific quantity such as position or velocity, we will use the names \\(x()\\), \\(y()\\), \\(z()\\), \\(u()\\), \\(v()\\), \\(w()\\), and such. These letters are, of course, the same ones we frequently use to name the inputs to functions. How do you know whether the letter is meant to refer to an input rather than a function? That’s the point of the parentheses: \\(x()\\) is a function name, \\(x\\) is an input name. It can become tedious to give a name to every function, even if it’s not being used again. Consider this awkward sentence as an example: “The functions \\(g(x) \\equiv \\sqrt{\\strut x}\\) and \\(h(x) \\equiv x^3\\) are examples of power-law functions.” So we’ll feel free to write instead, “\\(\\sqrt{\\strut x}\\) and \\(x^2\\) are examples of power-law functions.” Without the formality provided by “\\(g(x) \\equiv\\)” it can be hard to know whether \\(\\sqrt{\\strut x}\\) means “the square-root function” or \"take the square root of a specific number \\(x\\). The convention we will use is based on the name used in the expression. When standard argument names from the end of the alphabet are being used without any subscript (e.g. \\(x_0\\)) or with a special symbol as a subscript (e.g. \\(t^\\star\\)), we intend the expression to be a function. However, when we want to apply a function to specific values for inputs we will write in any of the following styles: \\[f(x^\\star) \\ \\ \\mbox{or}\\ \\ \\sqrt{\\strut x^\\star}\\ \\ \\mbox{or}\\ \\ \\sqrt{\\strut x=3}\\ \\ \\mbox{or}\\ \\ \\left.\\sqrt{\\strut x}\\right|_{x=3}\\ \\ \\mbox{or}\\ \\ \\left.g(x)\\strut \\right|_{x=3}\\] One of the important techniques of calculus is to take something we often think of as a number and turn it in to a function whose output is a number. It will take you time to get used to the calculus notation and to be able to tell at a glance whether something is a function or a number. Here’s an illustration that will only make sense to those who have already studied some calculus: \\[\\int\\! f(x) dx \\ \\ \\mbox{is a function, but}\\ \\ \\int_0^3\\! f(x) dx\\ \\ \\mbox{is a number.}\\] Give yourself a break as you’re learning the notation conventions. When you read a mathematical expression, a good first question to ask is, “What kind of thing is this? A function? A number?” A major reason that such care about notation is needed is that in addition to writing math in traditional mathematics notation (e.g. \\(e^x\\) (which, as the above indicates, is a function) or \\(\\ln(y^\\star)\\) (which is a number)) we need to be able to convey mathematical ideas to computers. Traditional mathematics notation was developed in the pre-keyboard era (that is, pre-typewriter era) and before the development of computer languages brought to the fore the effectiveness of structuring computing instructions as functions. For reference, here are some R expressions: f &lt;- makeFun(x^2 ~ x) defines a function f() that the computer can use. It means the same thing to the computer as \\(f(x) \\equiv x^2\\) means to the human reader. A tilde expression such as x^2 ~ x is a way of making clear that a symbol (x here) stands for the input to a function. x_pts^2 means to square the particular values stored under the name x_pts. To be sure, it’s also perfectly valid computer syntax to write x^2, since x is just as good a name for a computer object as x_pts. But we will avoid such use of names like x. For people who are already familiar with R, note that the style f &lt;- function(x) { x^2 } is the universally accepted way to write R functions. { x^2 } is the body of the function. (In CalcZ we use makeFun() as a kind of shorthand. makeFun() is provided by the {mosaic} package. EXERCISES: According to the notation style we use in CalcZ, which of these things is a function? Which a number? \\(\\sqrt{z}\\): function \\(\\sqrt{y^\\star}\\) number \\(e^{k t}\\) function of \\(t\\). The letter \\(t\\) is one of our standard letters for input names. \\(k\\) is a letter, but since it is not from the end of the alphabet, you have a hint that it is intended to be a parameter, that is a symbol representing a specific numerical quantity. \\(g(k) \\equiv e^k\\) a function of \\(k\\). Notwithstanding our convention that \\(k\\) is not on its own a name used for inputs, when we use the full function-definition style, anything in the parentheses following the function name is explicitly stated as an input name. "],["the-basic-modeling-functions.html", "Chapter 4 The Basic Modeling Functions", " Chapter 4 The Basic Modeling Functions "],["modeling-with-functions.html", "Chapter 5 Modeling with functions 5.1 The straight-line family 5.2 The exponential family 5.3 Power-law family 5.4 Logarithm and magnitude 5.5 Sinusoid family 5.6 Humps and sigmoids", " Chapter 5 Modeling with functions A central task in solving problems with mathematical modeling is the construction of appropriate functions to capture important features of the real-world situation you are working with. You’ve seen the notation that we’re going to use to describe functions to either the computer or the mathematical reader, and learned some of the terminology: function name, inputs, output, arguments, argument names, parameters, default values for parameters, algorithm, makeFun(), tilde expressions, and so on. The next step in developing modeling skills is to acquaint yourself with a set of basic modeling functions that provide important building blocks for the functions you will construct in your mathematical modeling work. Drawing on the collective experience of the mathematical modeling community, we have identified a small set of specific function families which address a large set of the most common modeling situations. The next several sections are like the displays in a hardware store. The display consists of a large number of collections of bins. Each collection consists of a single type of hardware, for instance, a washer. There are many collections because there are many kinds of hardware: bolts, wood screws, metal screws, nuts, washers, gaskets, etc. Typically, each collection involves a large number of bins containing different sizes or materials of the hardware item. Figure 5.1: Source Display racks of fasteners and other hardware. The function families you will study correspond to different kinds of hardware. We’ll need just a few—nails, screws, bolts, washers, nuts—enough to get you started on the common tasks. We call them a families of functions because most of them involve parameters, analogous to the different size of the hardware item. Depending on what field you work in, you may find yourself needing specialized functions: a “nut” is not enough, you will need to distinguish between wing nuts, wire nuts, cap nuts, flange nuts, tee nuts. (If you’re interested to see what a hardward store for mathematical functions looks like, explore the Digital Library of Mathematical Functions maintained by the US National Institute of Standards and Technology.) Here’s a list of what we are calling the basic modeling functions. Other authors might exclude one or two or include an alternate, but this list will serve you well. Linear function Exponential function Power-law function Logarithm Sinusoid Sigmoid Hump For each function in this list, you’re going to see the traditional mathematical name (if there is one), the parameter(s) used in the functions, the graphical “shape” of the function, and one or more common settings where the function is used. When appropriate, we’ll also see how to choose values for the parameters in order to match data as closely as possible. Each of these function takes a single input, which we’ll generally name \\(x\\) or \\(t\\). We’ll use names for the parameters that are more or less standard in the literature While we’re making the list, we’ll add two functions that appear in often in combination with the above but which are so modest that people don’t always notice them. By naming them, we’ll be able to point out the roles they play. The constant function The proportionality function 5.1 The straight-line family i. (Fun-1C-a) *Review (from previous math classes) the parameters of the straight-line function: y-intercept and slope.* ii. (Fun-1C-b) *Use a straight-line function in a modeling context.* iii. (Fun-1C-c) *Spot discrepancies of data from a straight-line model.* iv. (Fun-1C-d) *Construct a hock-stick function by piecewise combination of a constant function and a straight-line function with non-zero slope.* We’ll start with a simple function that appears throughout calculus and mathematical modeling. You probably have heard this function called a “linear function,” but we prefer to call it a “straight-line” function since its graph is a straight line. (Aside for the mathematically experienced: Strictly speaking, what’s called the linear function does not have the technical property of linearity, which in mathematics means something subtly different than “straight line.” We’ll need the mathematical property of linearity later in CalcZ.) Let’s define a function \\(g()\\) which is a straight-line function: \\[g(x) \\equiv m x + b\\] You likely have worked a lot with this kind of function in your previous math courses. If so, recall that there are two parameters, \\(m\\) and \\(b\\) called the slope and y-intercept respectively. The straight-line function might be thought of as the default modeling function. If you want to describe a relationship between two quantities, using the straight-line function can often be just what’s required. In using calculus, we’ll often be zooming in on a function over a tiny domain. Just about any function, when looked at over a tiny domain, is approximately a straight-line function. To illustrate, consider the data plotted below recording monthly household natural gas use for the author’s family. This varies from month to month, and since gas is mainly used for heating the house, it’s reasonable to think that gas usage is related to the outdoor temperature. Each dot in the graph shows one month’s data, with temperature measured in degrees F and natural gas measured by volume: cubic feet appreviated ccf. A straight-line function has been fitted to the data. The graph has several features that are not unusual when using data to construct a mathematical model. The function selected, which gives ccf versus outdoor temperature, is roughly centered on the cloud of data. That is, for a given input value, the function output goes through the vertical center of the data points near that input value. For part of the domain, the function is a good match to the data. For another part of the domain, temperatures above about 60 degrees, the function deviates systematically from the data. Indeed, the output of the function is negative when temperature is above the mid 60s. (Of course, the amount of natural gas used can hardly be negative!) There are a few data points, near 40 and 60 deg. F that are far from the output of the model at those temperature. Such points are called outliers. One of the uses of mathematical models in interpreting data is to make it easier to spot data records that don’t fit an overall pattern. (From the graph itself, one can only speculate about what might be responsible for the outliers. Here it seems to be an error in transcribing the data.) The straight-line function has two parameters: the slope and the intercept. Since the domain of the graph includes 0, we can read the intercept directly from the graph: at an input of 0 the function output is roughly 300 ccf. The slope is, famously, the “rise over run.” Mark off a convenient interval on the domain. We’ll use 0 to 64 degrees. Then find the vertical interval of the function output over that interval on the domain. We selected 0 to 64 for the domain since the function output is easy to read: about 300 ccf at 0 deg and 0 ccf at 64 degrees. The amount of “rise” is therefore \\(0-300\\) ccf and the run is \\(64 - 0\\) deg, so the slope is \\[\\frac{0-300}{64-0} \\frac{\\text{ccf}}{\\text{deg}} \\approx -4.6 \\frac{\\text{ccf}}{\\text{deg}}\\] The negative sign on the slope indicates that the function output falls as the input increases. For a straight-line function, you will find the same slope whatever non-zero interval on the domain you choose for the run. Many other kinds of functions have a slope that differs for different inputs. One of the central ideas of calculus is that even for non-straight-line functions, a meaningful calculation of the slope at a single input can be constructed. We’ll examine that issue carefully later in the course. In calculus, the slope of a function is a quantity of particular interest. Here, the slope tells us that a one degree increase in outdoor temperature (averaged over a month) corresponds to a 4.6 ccf decrease in natural gas use. As you’ll see later in the course, the slope of a function is the sensitivity of the output to a change in the input. It’s often the case that a given model accounts for only part of the pattern seen in data. There are many synonyms for “accounts”: “captures only part of the pattern,” “matches only part of the pattern,” and so on. The blue straight-line model in Figure ?? doesn’t account for the leveling out of natural gas use for temperatures greater than about 60 degrees. Modelers look for such discrepancies between a candidate model (here, the blue line) and the data. Sometimes such discrepancies indicate that the wrong kind of mathematical function has been selected for the model or that the model has not been fitted to the data properly. A skilled modeler will treat the discrepancies as an opportunity to learn more about the real-world system being modeled. With this additional knowledge, a better model can be constructed. Those familiar with home heating will know that for temperatures about about 60 degrees F, no heating is necessary and fuel use for heating falls to zero. But there are other uses for fuel such as cooking and water heating. To judge from the data, those uses don’t depend in any strong or obvious way on outdoor temperature. Exercise: Compare the straight-line model fitted to all the ccf data to the model fitted to data where the temperature was less than 60 degrees. Implement as heating_ccf(temp) Exercise: Make a straight-line model for the energy used for cooking and heating. Implement as other_ccf(temp) Exercise: Piece together the two models to make a more comprehensive model of energy use. Show the computer implementation of this function. all_ccf &lt;- makeFun( ifelse(temp &lt; 60, heating_ccf(temp) + other_ccf(temp), other_ccf(temp)) ~ temp) 5.2 The exponential family Objective (Fun-2a) Recognize the key characteristics of an exponential function’s graph, to include both increasing and decreasing exponential functions Additional objective (not numbered) Use correctly statements like, “the slope of the function \\(g(x)\\) with respect to \\(x\\) is a function of \\(x\\).” An important concept in calculus is the change in output of a function for a given change in input. The experiment to measure a change in output is very simple: Start with some fixed value for the input \\(x_0\\) and record the function output \\(f(x_0)\\). Change the input by an amount \\(h\\) and record the function output \\(f(x_0 + h)\\). The change in input is \\(h\\), the corresponding change in output is \\(f(x_0 + h) - f(x_0)\\). You can choose whatever value for the change in input \\(h\\) is convenient. Often, the choice is “one unit of input.” Obviously, this depends on how you quantify the input. For instance, in Figure ??, where we looked at natural gas usage (ccf) as a function of average monthly temperature (deg. F), a unit of input is 1 degree F. The change in output divided by the change in input is, as you know, the slope of the function. For a straight-line function in Figure ?? the slope is \\(-4.6 \\frac{\\text{ccf}}{\\text{deg}}\\). “Slope” is a nice physical metaphor, but talking about the “slope of gas use” is bound to be confusing. People who are familiar with calculus use the word “derivative,” as in “derivative of gas use with respect to temperature.” For a straight-line function, the “derivative” is constant, that is, it doesn’t change with \\(x_0\\). The exponential function is our first basic modeling function family with a non-constant derivative. Figure ?? shows the function \\(f(x) \\equiv e^{x}\\). For use in modeling, we generally have to pick the right “shape” from the exponential family. We’ll generally write the exponential function with a parameter \\(k\\) and the formula \\(e^{kt}\\). Figure ?? shows exponential functions with several different numerical values for the parameter \\(k\\). Some features of the members of the exponential family \\(g(x) \\equiv e^{kx}\\): When \\(k &gt; 0\\) the function output increases with \\(x\\). But when \\(k &lt; 0\\) the function output decreases as \\(x\\) gets bigger. For any \\(k\\), the value of \\(g(0) = 1\\). When \\(k &gt; 0\\), the value of \\(g(x)\\) becomes very small when \\(x\\) is negative but large (that is, to the left). When \\(k &lt; 0\\), the value \\(g(x)\\) becomes very small when \\(x\\) is positive and large. A way to say this in symbols is that, for negative \\(k\\), the limit as \\(x \\rightarrow \\infty\\) is zero. Similarly, for positive \\(k\\), the limit \\(x \\rightarrow -\\infty\\) is zero. We use the word asymptotic to denote such limits. Notice that as the value of \\(g(x) \\rightarrow 0\\) the function gets flatter. That is, as \\(g(x) \\rightarrow 0\\), the slope of \\(g(x)\\) also goes to zero. And when \\(g(x)\\) is large, the slope is also large and either positive or negative depending on \\(k\\). Objective (Fun-2b) Know that exponential functions have the property that their slope (rate of change) at each input is proportional to the height of the function at that same input. And that the slopes approach zero in one of the directions Look back at Figure ??. Clearly the slope of each of the functions is different for different values of the input \\(x\\). Better to say this using function language: The slope of the exponential function \\(f(x)\\) is itself a function of \\(x\\). With this sort of language in mind, we can return to the description of the slope of a straight-line function and say any of these: “the slope of the straight line function \\(g(x) \\equiv m x + b\\) is not a function of \\(x\\)” or “the slope of \\(g(x)\\) is constant with respect to \\(x\\),” or “the slope of \\(g(x)\\) is a constant function with respect to \\(x\\). A”constant function\" is one whose output does not depend on the input, for instance \\(\\text{const}(x) = 7\\). (In terms of an office building, a constant function is a building where the worker at every door gives exactly the same response, here 7.) You can see from Figure ?? that the slope of the exponential function is positive and gets bigger as \\(x\\) gets bigger. You could draw lots of functions whose slope is an increasing function of its input. But there’s something very special about the exponential function that gives it a high status among the basic modeling functions: The slope of the exponential function is alway proportional to the value of the exponential function. It’s worth unpacking that simple statement a bit. We have an exponential function \\(g(x) \\equiv e^x\\). The slope of the exponential function is, as we have described, \\[\\text{slope of}\\ g(x)\\ \\mbox{is} \\ \\frac{e^{x + h} - e^x}{h} = \\frac{e^x e^h - e^x }{h} = e^x \\frac{e^h - 1}{h}\\] Look carefully at the term \\((e^h - 1)/h\\). Notice that there is no \\(x\\) in it. Thus, the function \\((e^h - 1)/h\\) is constant with respect to \\(x\\). In other words \\[\\text{slope of}\\ g(x)\\ \\mbox{is} \\ \\mbox{constant} \\times e^x\\]. EXERCISE: Compute \\((e^h - 1)/h\\) for \\(h=2, 1, .1, .01, .001\\). Describe what happens. (We might write, “As \\(h \\rightarrow 0\\), the quantity \\(\\frac{e^h - 1}{h} \\rightarrow 1\\).”) The exponential function is particularly useful when the quantity we want to model shows constant proportional increase. Many quantities in everyday life are this way. For instance, if you get an increase in salary you typically say something like “a 3% increase.” The population growth of a country is often presented as “percent per year.” Inflation in the price of goods is similarly described in percent per year. Interest on money in a bank savings account is also described as percent per year. But if you have the bad fortune to owe money to a loan shark, the proportional increase might be described as “percent per month” or “percent per week.” EXERCISE: Go back to Figure ?? and calculate the percent increase in the output of \\(g(x)\\) when \\(x\\) is increased by one unit. LEAD THEM THROUGH DOING THIS FROM x=0 to 1, and then for other starting points. Objective (Fun-2c) Know how changing the values of C and k affect the properties of the exponential model \\(g(x) \\equiv C e^{kt}\\) (table page 62) Objective Revised (Fun-2c) Understand that \\(e^{kt}\\), \\(2^{k_2 t}\\), and \\(10^{k_{10} t}\\) are all the same function, when \\(k = k_2 \\ln(2) = k_{10} \\ln(10)\\). Relate \\(k_2\\) to the doubling time and \\(k_{10}\\) to the time to increase 10-fold. Write CONTENT FOR Fun-2c 5.3 Power-law family Objectives: (Fun-2d) Distinguish between exponential functions and power-law functions. (Fun-2e) Relate power-law functions to physical quantities. Exponential functions such as \\(f(t) \\equiv e^{kt}\\) or \\(f_2(t) \\equiv 2^{k_2 t}\\) and \\(f_{10}(t) \\equiv 10^{k_{10} t}\\) (all of which can be arranged to produce exactly the same output for corresponding values of \\(k\\), \\(k_2\\), and \\(k_{10}\\)) can be remembered as such because the function input appears as an exponent in the function formula. There is a very different kind of function, called a power-law function, which is different from an exponential, and has different uses, yet is very often confused. In a power-law function, the input is being raised to a power, for example, \\(g(t) \\equiv t^2\\). The exponent is a parameter and the input is being raised to the indicated power, for instance 2 for \\(g(t)\\). Figure ?? shows a few members of the power-law family with different exponents, both positive and negative. For contrast, one exponential function is also drawn (in green). As you can see, the shapes of power-law functions can be very different depending on the value of the exponent parameter. For many values of the exponent parameter, the function domain is \\(-\\infty &lt; t &lt; \\infty\\) while for others the domain is just the positive numbers: \\(0 &lt; t &lt; \\infty\\). None of them resemble an exponential function. What do all these differently shaped functions have in common that warrants them all being placed in the same family? Of course, they all involve raising the function input to a power: positive or negative, integer or otherwise (e.g. 1.5). The main thing they have in common is the settings they are used in. You have been using power-law functions from early in your math and science education. Some examples: Setting Function formula exponent Circumference of a circle \\(C(r) = 2 \\pi r\\) 1 Area of a circle \\(A(r) = \\pi r^2\\) 2 Volume of a sphere \\(V(r) = \\frac{4}{3} \\pi r^3\\) 3 Distance traveled by a falling object \\(d(t) = \\frac{1}{2} g t^2\\) 2 Gas pressure versus volume \\(P(V) = \\frac{n R T}{V}\\) \\(-1\\) … perhaps less familiar … Distance traveled by a diffusing gas \\(X(t) = D \\sqrt{ \\strut t}\\) \\(1/2\\) Animal lifespan (in the wild) versus body mass $L(M) = a M^{0.25} 0.25 Blood flow versus body mass \\(F(M) = b M^{0.75}\\) 0.75 The reason why power-law functions have their important role in science have to do with the logic of physical quantities such as length, mass, time, area, volume, force, power, and so on. We’ll discuss this at length later in the course and the principles will appear throughout calculus. SHOW SOME ALLOMETRIC GRAPH 5.4 Logarithm and magnitude Objective (Fun-3a1) Understand a logarithm (base-10) as signifying the magnitude of a number by the digit count. See \\(\\log_2()\\) and \\(\\log_{10}()\\) as counting digits in base-2 and -10 respectively. Let’s talk about logs. For many students, logarithms are the breaking point in their mathematical studies. I’ve encountered well educated professionals who are evidently afraid of logarithms and take the word itself as a promise that what’s coming will be hard to understand. I suspect that some of this comes from being introduced to logarithms as a means of dealing algebraically with power-law and exponential functions. If logarithms are a source of anxiety because of their association with algebra and concerns about what use they could otherwise be for, take a step back, close your eyes, and we’ll start over, but more gently. Undoubtedly you are comfortable with the standard way of writing numbers, for instance 33 or 512 or 1051. Elementary school students master the comparison of such numbers to one another. Which is greater: 512 or 33? Which is less, 1051 or 512? You can answer such questions at a glance because the comparison here can be accomplished simply by counting the number of digits. 1051 has four digits, so it is larger than the three-digit number 512. There are two digits in 33, so it smaller than 512. When two numerals have the same number of digits—say, 337 and 512—you can’t answer the “greater than” question by simple counting. Instead, you proceed from left to write and compare the number in each place. So, for 512 and 337, you compare 5 to 3 and … since 5 is greater than 3, 512 is greater than 337. If the two leading digits are the same, go on to the next digit and so on for all the digits in turn. Things were not always this simple. Our number system that uses place and Arabic numerals is a human invention. An example of an earlier number system is Roman numerals. Here, comparison is hard. For instance, which of these three numbers is bigger? \\[\\mbox{MLI or CXII or XXXIII}\\] The typographically shorter number is the largest, and vice versa. Even when two Roman numerals have the same length, it’s not trivial to compare them on a place-by-place basis. For instance, IC is about fifteen times bigger than VI, even though I is much smaller than V. Digit counting provides an easy, fast way to perform many calculations, at least approximately. What is \\(\\sqrt{10000}\\)? There are five digits, and the square root of a number will have “half the number of digits.” So, \\(\\sqrt{10000} = 100\\). What is \\(10 \\times 34\\)? Easy: 340. Just append the one zero from 10 to the end of 34. What is \\(1000 \\times 13\\)? Just as easy: 13,000. We even punctuate written numbers with commas and a period in order to facilitate counting digits. Imagine having a digit counting function called digit(). It takes a number as input and produces a number as output. We don’t have a formula for digit(), but for some inputs the output can be calculated just be counting. For example: digit(10) \\(\\equiv\\) 1 digit(100) \\(\\equiv\\) 2 digit(1000) \\(\\equiv\\) 3 … and so on … digit(1,000,000) \\(\\equiv\\) 6 … and on. The digit() function easily can be applied to the product of two numbers. For instance: digit(1000 \\(\\times\\) 100) = digit(1000) + digit(100) = 3 + 2 = 5. Similarly, applying digit() to a ratio gives the difference of the digits of the numerator and denominator, like this: digit(1,000,000 \\(\\div\\) 100) = digit(1,000,000) - digit(100) = 6 - 2 = 4 For an input \\(x\\) consisting of a 1 followed by zeros, any fool can calculate the output: just count the zeros. But for other numbers, it’s not so easy. The people who originally proposed the crazy-sounding notion that digit() can be applied to numbers like 32 were wild innovators of the late 16th and early 17th centuries, but they had ideas about how to do the calculation. Some examples: 32 \\(\\times\\) 32 . So, digit(32 ) digit(1000) = 3$. Applying the multiplication rule means digit(32) + digit(32) \\(\\approx\\) 3, so digit(32) \\(\\approx\\) 1.5. \\(32 = 2 \\times 2 \\times 2 \\times 2 \\times 2\\) Since digit(32) \\(\\approx\\) 1.5, we know that 1.5 \\(\\times\\) digit(2) which tells us that digit(2) \\(\\approx\\) 0.3. It’s hard to do such calculations in your head, but fortunately the arithmetic whizzes who invented digit() could handle it and made tables giving the output of digit(\\(x\\)) for many different values of \\(x\\). Here’s part of the first page of the first widely published table, in 1617. The project was supervised by Henry Briggs. (1561-1630) The table was called the Chilias prima, Latin for “First group of one thousand.” True to its name, the table gives the output of digits() for the inputs 1, 2, 3, …, 998, 999, 1000. For instance, as you can see from the top row of the right-most column, digits(67) = 1.82607480270082. In everyday speech, 67 has two digits. The authors of Chilias prima sensibly didn’t use the name “digit()” for the function. They chose something more abstract: “logarithm().” Nowadays, this function is named \\(\\log_{10}()\\). In R, the function is called log10(). log10(67) ## [1] 1.826075 Our main use for \\(\\log_{10}()\\)/log10() will be to count digits in order to quickly compare the magnitude of numbers. The difference digits(\\(x\\)) - digits(\\(y\\)) tells how many factors of 10 separate the magnitude of the \\(x\\) and \\(y\\). Another important logarithmic/digit-counting function is \\(\\log_2()\\), written log2() in R. This counts how many *binary digits are in a number. For us, \\(\\log_2(x)\\) tells how many times we need to double, starting at 1, in order to reach \\(x\\). For instance, \\(\\log_2(67) = 6.06609\\), which indicates that \\(67 = 2\\times 2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2^{0.06609}\\) \\(\\log_2(x)\\) and \\(\\log_{10}(x)\\) are proportional to one another. One way to think of this is that they both count “digits” but report the results in different units, much as you might report a temperature in either Celsius or Fahrenheit. For \\(\\log_2(x)\\) the units of output are in bits. For \\(\\log_{10}(x)\\) the output is in decades. A third version of the logarithm function is called the natural logarithm and is denoted \\(\\ln()\\) in math notation and simply log() in R. We’ll need additional calculus concepts before we can understand what justifies calling \\(\\ln()\\) “natural.” EXERCISE: Compute \\(10^y\\) to convert a “number of digits” into the number whose digits are being counted. For instance, \\(10^2.5\\) is 316.228. EXERCISE: How many binary digits in 64? in 127? EXERCISE: \\(\\log_{10}(x)\\) and \\(\\log_2(x)\\) are proportional to one another. What’s the constant of proportionality? POSSIBLE COMPUTATIONAL ENRICHMENT: AN EXAMPLE OF A FUNCTION DESCRIBED AS A COMBINATION OF A FORMULA AND A COMPUTER ALGORITHM small_log &lt;- function(x) { if (x &lt; .99 || x &gt; 1.01) stop(&quot;x must be in range 0.99 to 1.01.&quot;) x &lt;- x - 1 (x - x^2/2 + x^3/3 - x^4/4 + x^5/5 - x^6/6 + x^7/7)/2.30258509299405 } my_log &lt;- function(x) { if (x &gt;= 10) my_log(x/10) + 1 else if (x &lt; 0.1) my_log(10*x) - 1 else if (x &gt; 0.99 &amp;&amp; x &lt; 1.01) small_log(x) else 2*my_log(sqrt(x)) } 5.5 Sinusoid family Objective (Fun-3B-a) Become familiar with the sinusoid functions and the period parameter. Be able to identify the period from the graph of a sinusoid-like function. Onward to our next basic modeling function: the sinusoid. The word “sinusoid” may bring to mind your studies of trigonometry. As you know, “trigonometry” is the study and measurement of triangles, that is, polygons with three sides. Admittedly, the word “trigon” does not bring to mind a triangle as well as the words “pentagon,” “hexagon,” and “octagon” are associated with 5-, 6-, and 8-sided polygons. Trigonometry is a standard part of the high-school mathematics curriculum, so I’m going to assume that you know the names of various trigonometric functions, e.g. \\(\\sin()\\), \\(\\cos()\\), \\(\\tan()\\), and a host of others that have names that are easily confused or forgotten. Trigonometry has always been an important mathematical topic because of its use in surveying (George Washington was a trained surveyor), navigation, building and design, and other trades. It is still well worthwhile for any technical worker to master the use of trigonometry. But this is not why it’s coming up here in CalcZ. Including the sinusoid in our small set of basic modeling functions has nothing to do with triangles or the many practical applications of trigonometry. Instead, we need it as a standard model for a highly important phenomena: things that repeat themselves in a cycle, over and over again. We use the word “sinusoid” rather than, say “sine” because there are two closely related functions, \\(\\sin()\\) and \\(\\cos()\\) that are more or less interchangeable when it comes to modeling. For now, we could do with just one or the other. Later in CalcZ, however, it will be useful to have them both for the purposes of keeping track of some mathematical operations. Also, we will not generally have a use directly for a function \\(\\sin(t)\\). Instead, we’ll work with a parameterized function \\(\\mbox{sinusoid}(t) \\equiv \\sin(2\\pi t/P)\\), where \\(P\\) is called the “period” of the function. Figure ?? shows the graph of a sinusoid with \\(P=1\\) and another with \\(P=0.3\\) The graphs show the same graphic domain: \\(-2 &lt; t &lt; 2\\). (The mathematical domain, that is, the set of valid inputs, is \\(-\\infty &lt; t &lt; \\infty\\). For the sinusoid of period \\(P=1\\), four cycles are fitting in to the graphic domain we selected. For the sinusoid of period \\(P=0.3\\), a little more than 12 cycles fit into the graphic domain. A cycle is the function over a part of the domain where the function starts at a particular value (say, sinusoid(t) = 0) and first returns back to its staring value and to its starting slope. You can choose any starting value you like to define a cycle. For the purposes of measuring the period from a graph, I find it convenient to start at the peak, that is, somewhere that \\(\\mbox{sinusoid}(t) = 1\\) or the trough (that is, \\(\\mbox{sinusoid}(t) = 1\\)). No matter what you choose, you will get the same answer. Examples of real-world phenomena that are roughly sinusoidal: the temperature at any location on Earth which has a period of 1 year; the brightness of the Moon which has a period of about 27.322 days; the position on a beach of the sort of bird that runs away from breaking waves and toward retreating waves (period: several seconds); any other kind of wave including radio wave. (The period of a radio wave depends on the “band,” for FM radio it’s roughly one one-hundred millionth of a second. For WIFI waves have a period of roughly a quarter of a billionth of a second, so about 40 times shorter than FM radio waves). Of course, the phenomena we model with sinusoids are not generally exactly periodic. The moon and the weather are pretty reliable, but breaking wave don’t always come in exact rhythm. A radio wave that is exactly periodic is called a “carrier,” but the transmission of information—sound, movies, documents, etc.—necessarily involves some deviation from exact periodicity. Still, a sinusoid is a pretty good place to start modeling even those phenomena that are not exactly periodic. Notice that in the above we’re using \\(t\\) for the name of the input to the sinusoid. Of course, we could use any name at all for the input. We’re prompted to use \\(t\\) rather than our usual \\(x\\) because one of the most important uses for sinusoids is in modeling functions that repeat in time over and over again. It’s entirely your choice how The domain of \\(\\mbox{sinusoid}(t)\\) is the entire number line. The range is the interval from -1 to 1, and the ink in a sinusoid graph is balanced on either side of zero. A more general parameterization of a sinusoid is \\(\\sin(2\\pi(t-t_0)/P)\\). \\(P\\) is still the period and \\(t_0\\) is a specific input at which the output is increasing from 0. Often, this richer parameterization is written somewhat differently: \\(\\sin(2\\pi(t-t_0)/P) = \\sin(2\\pi t/P - 2\\pi t_0/P) = \\sin(\\frac{2\\pi t}{P} - \\phi)\\). The parameter \\(\\phi\\) is called the phase. For us in CalcZ, we will mostly be concerned with the period parameter and you won’t see the phase appearing often. 5.6 Humps and sigmoids Objectives (Fun-3B-a) Recognize general graphical features of sigmoidal functions and their associated hump functions (Fun-3B-b) Explain why the slope function of a sigmoidal function is a hump function (Fun-3B-c) OPTIONAL Be aware of different formulations for the hump sigmoidal functions. Our last two basic modeling functions express an important idea in modeling: localness. To put this in concrete terms, imagine creating a function to depict the elevation above sea level of a long road as a function of distance in miles, \\(x\\), from the start of the road. If the road were level at 1200 feet elevation, a sensible model would be \\(\\mbox{elevation}(x) = 1200 \\text{ft}\\). If the road were gently sloping, a better model would be \\(\\mbox{elevation}(x) = 1200 + 3 x\\). Now let’s add a bump to the road. A bump is a local feature, often only a few feet wide. Or, perhaps the road is crossing a mountain range. That’s also a local feature, but unlike a bump in the road a mountain range extends for many miles. The basic modeling function suited to represent bumps in the road, or potholes, or mountain ranges is called a hump function. A hump function has two parameters: the location of the hump, which we’ll call the center parameter, and the extent of the hump, which we’ll call the spread. Figure ?? shows a few hump functions with different parameters. It’s easy to read off the center parameter from a graph of a hump. It’s the location of the top of the hump. (We mentioned before that a mathematical word for “the location of the top” is argmax; the value for the input of the function that produces the maximum output.) The spread parameter is also pretty straightforward, but you first have to become familiar with an unusual feature of the hump function. The output of the hump function far from the center is practically zero. But it is not exactly zero. You can see from the graphs that the hump function has long flanks which approach zero output more or less in the manner of an exponential function. This means that we can’t measure the spread of the hump function by the distance between the zeros on either side of the peak. Instead, we need a convention that will allow us to be precise in quantifying what is admittedly a vague concept of width. A simple convention is that the spread is the “half-width at half-height.” Come down half-way from the peak of the hump. Panel (c) of Figure ?? marks that elevation with a thin, red, horizontal line. Along that line, measure the width of the hump, as marked by the thick red line in Panel (c). The spread parameter is half the width of the hump measured in this way. If you have a keen eye, you’ll notice that the red line is not exactly half-way down from the peak. It’s down 39.35% from the peak. The official definition of width of a hump is not actually half-width at half-height, but that simple formulation will do for us for the present. Another seeming oddity about the hump function is the value of the maximum. It would have seemed natural to define this as 1, so-called “unit height.” The way it actually works is different: the maximum height is set so that the area under the hump function is 1. This business with the area will make more sense when you’ve learned some calculus tools, specifically “differentation” and “integration.” For now though … Consider another road feature, a local change from one elevation to another as you might accomplish with a ramp. The basic modeling function corresponding to a local change from one level to another is the sigmoid function. Figure ?? shows three sigmoid functions. The name “sigmoid” comes from vague resemblance of the graph to the letter S (which is “sigma” in Greek: ς). The parameters of the sigmoid function are the same as for the hump function: center and width. The center is easy to estimate from a graph. It’s the value of the input that produces an output of 0.5, half-way between the max and min of the sigmoid. As with the hump function, the width is measured according to a convention. The width is the change in input needed to go from an output of 0.5 to an output of 0.8413. This use of 0.8413 must seem luny at first exposure, but there is a reason. We’ll need more calculus tools before it can make sense. Hump functions and sigmoid functions with the same center and width parameters have a very close relationship. The slope of the sigmoid function is the corresponding hump function. Figures ?? and ?? show corresponding hump and sigmoid functions. To the very far left, the sigmoid function is effectively flat: a slope near zero. Moving toward the center the sigmoid has a gentle slope: a low number. In the center, the sigmoid is steepest: a higher number. Then the slope of the sigmoid becomes gentle again before gradually falling off to zero. Near zero, then low, then higher, then low again, then falling off to zero: that’s also the description of a hump function! In R, the name of the sigmoid function is pnorm(). The hump is dnorm(). The parameters that specify center and spread are named mean and sd. The word “mean” accurately conveys the idea of “center.” It would be nice to be able to say that sd comes from spread, but in fact sd is short for “standard deviation.” Unlike the celebrity functions like exponentials, logarithms, power-laws, and sinusoids, there is not universal agreement across technical fields what should be the precise definition of a hump or sigmoid function. Figure ?? compares two widely used versions of the hump and sigmoidal functions. The sigmoidal logistic function (drawn in red in Figure ??) is a favorite among mathematicians. Its formula is \\[\\mbox{sigmoid}_\\mbox{logistic}(x) \\equiv \\frac{1}{1 + e^{-k(t-t_0)}}\\] The parameter \\(t_0\\) is the center. The spread (as we defined it earlier along the lines of half-width at half-height) is roughly \\(1.5/k\\). Since the hump function is the slope of the sigmoid function, the formula for \\(\\mbox{sigmoid}_\\mbox{logistic}(x)\\) gives directly the hump’s formula: \\[\\mbox{hump}_\\mbox{logistic}(x) \\equiv \\frac{k e^{-k(t-t_0)}}{(1 + e^{-k(t-t_0)})^2}\\] The Gaussian function (drawn in blue) is much more widely used in science and statistics. It’s formula is \\[\\mbox{hump}_\\mbox{gaussian}(x) \\equiv {\\small \\frac{1}{\\sqrt{2\\pi \\sigma^2}}} e^{\\frac{(t - t_0)^2}{2 \\sigma^2}}\\] As you can see from Figure ??, the logistic and the gaussian formulations are very similar. For many modeling purposes, either one would do. The important features are that the functions are smooth with gentle curves, the sigmoid rises from 0 to 1 in output, and the area under the hump is 1. An amazing bit of trivial is that there is no formula for \\(\\mbox{sigmoid}_\\mbox{gaussian}()\\). You might ask, “If there is no formula, how can we use the function?” The answer is that even though there is no formula, there is an algorithm for calculating the value of \\(\\mbox{sigmoid}_\\mbox{gaussian}(t)\\). We’re now starting to get into the center of the realm of calculus, which provides us new concepts and notation for describing the correspondance between functions. We’ll need much of CalcZ to introduce and master these concepts and their notation. For now, we will let the notation make a cameo appearance, a premonition of what is to come. To say, “the slope of the sigmoid function is the hump function,” we write \\[\\partial_t \\mbox{sigmoid}(t) = \\mbox{hump}(t)\\] To describe an algorithm for computing the output of the sigmoid function, we need somehow to move the \\(\\partial_t\\) from the left side of the equation to the right side. This is a subtle operation and is conventionally written \\[\\mbox{sigmoid}(t) = \\int_{-\\infty}^t \\mbox{hump}(x) dx\\] If you haven’t studied calculus before, \\(\\partial_t\\) and \\(\\int\\) will be new to you. You can hardly be expected at this point to understand them. But now you’ve seen them and will hopefully come to be friends with them. "],["functions-and-patterns.html", "Chapter 6 Functions and patterns 6.1 Average rate of change 6.2 Instantaneous rate of change", " Chapter 6 Functions and patterns As you know, a function takes one or more inputs and returns a value as output. The functions we examine in CalcZ take quantities as inputs and return a quantity as an output. The algorithm that forms the body of the function describes arithmetic and other calculations that can turn the inputs into the output. On the other hand, we can also use tables as functions. With a table, you specify the input, look up that input in one of the colums of the table which brings you to the right row. Then read out from that row the value in another column to be the output. The quantitative operation needed for table lookup is simple comparison. The floor/corridor/door metaphor describes table lookup as well as function evaluation. In the previous block, we constructed functions to represent the patterns seen in data. In one example, we constructed a function \\(g(t) = A + B e^{-k t}\\) to represent the temperature of water cooling in a mug as a function of time. In another example, we summarized the pattern of rising and falling tides. It’s common sense that data is stored in tables. But we could easily represent any smooth mathematical function, such as our basic modeling functions, as a table look-up problem. Indeed, in the era before computers, many mathematical functions were used in exactly this manner: a printed table in which a person could search for a match to the input and retrieve a value for the output. [Picture of some nice old table.] In the computer era, we still routinely represent functions this way: data stored in computer files. For instance, an MP3 file is not much more than a sequence of numbers that record a complicated function of time: the air pressure variations of sound. Similarly, digital images record functions of \\(x\\) and \\(y\\) over a limited domain. Given \\(x\\) and \\(y\\) as input, you can look up the output by going to the right pixel. We humans of course, don’t perceive the numerical output of either sound or image functions: we hear a sound and we see an image. We’ve got special biological equipment for this! Consider the image in Figure @ref{fig:sand-1}. It is a picture of some indentations in a small area of sand, about two inches wide in the middle of a hiking trail. The dots are individual grains of sand. Can you see three almost parallel furrows? How about the small crater in the upper left? You can see the individual grains of sand because they contrast sharply with their neighbors. Or, more precisely, you can see a few dozen grains because they contrast sharply with their neighbors. You can think of the surface of the sand as a function of \\(x\\) and \\(y\\). It’s lower in some places and higher in others. But, in fact, you can’t see the height of an individual point in the photograph. In the right light, you wouldn’t notice the furrows at all. But the way the picture is lighted, raking sunlight from the left, the surface is translated into broad regions of brightness and shadow. In the light regions, the surface slants toward the sun. In the shadows, the surface slants away from the sun. What you’re mainly seeing in the photo is the slant or slope of the surface. The light has transformed elevation as a function of \\(x\\) and \\(y\\) into slant as a function of \\(x\\) and \\(y\\) and then encoded the slant as brightness, in much the same way the background of a contour plot encodes the output of the function as a color. The moral here is that sometimes the data in a function is not in the right form for us to extract useful information. But by transforming that data to represent contrast or difference or slope, the information can be revealed. This Block is about transforming functions to show difference and slope. Such transformation, accomplished by mathematics rather than the raking light of the sun, can take a pattern that we’re presented with and turn it into another pattern that can tell us what we want to know. 6.1 Average rate of change [Deriv-2a] Identify the “average rate of change” of a function over an interval as the overall change in output divided by the change in input. As you know, one way to calculate the slope of a straight-line function \\(f()\\) is to pick two different values for the input: call the larger of them \\(x_1\\) and the smaller \\(x_0\\). Think of these input values as the endpoints of an interval or neighborhood of the domain. The length of this domain is \\(x_1 - x_0\\). Evaluate the function at those endpoints and calculate the slope simply as the difference in output divided by the length of the interval: \\[\\frac{f(x_1) - f(x_0)}{x_1 - x_0}\\] “Slope” is a natural metaphor when thinking of a function as a graph. But a more general way to describe the concept is the rate of change of the output with respect to the input. The change in the output from one end of the interval is \\(f(x_1) - f(x_0)\\), the change in the input is \\(x_1 - x_0\\). If the input is time (in hours), and the output is the position of a car (in miles), then the rate of change is miles-per-hour: the car’s velocity. For a straight-line function—think of a car driving at constant speed on a highway—it doesn’t matter what you choose for \\(x_1\\) and \\(x_0\\) (so long as they are not identical). But for other functions, the choice does matter. Imagine a graph of the position of a car along a road as in Figure @ref{fig:stop-and-go}. Over the course of an hour, the car travelled about 25 miles. In other words, the average speed is 25 miles/hour: the slope of the red line segment. Given the traffic, sometimes the car was stopped (time C), sometimes crawling (time D) and sometimes much faster than average (time B). During the interval from B to C, the car was travelling relatively fast. The slope of the brown segment connecting the position at times B and C is the average rate of change between times B and C. It’s easy to see that the average rate of change from B to C is larger than the overall average from \\(t=0\\) to \\(t=1\\). Calculating that slope is a matter of evaluating the position at the endpoints and dividing by the length of the interval. What is the average rate of change in the car’s position during the interval \\(t_B = 0.40\\) to \\(t_C=0.54\\)? The length of the interval is \\(t_C - t_B = 0.54-0.40=0.14\\). Evaluating the function gives \\(x(t_C) = 18\\) and \\(x(t_B) = 12.6\\). Rise is \\(x(t_C) - x(t_B) = 18 - 12.6 = 5.4\\). Run is \\(t_C - t_B = 0.54-0.40=0.14\\). The average rate of change during the interval is $5.4/0.14 = 38.6 $ miles/hour. The graph shows a simplified model of the amount of usable wood that can be harvested from a typical tree in a managed forest of Ponderosa Pine. (You can see some actual forestry research models here.) You are writing a business plan for a proposed pine forest. Among other things, you have to forecast the revenue that will be generated and when you will have salable product. They say that “time is money.” Every year you wait before harvest is another year that you don’t have the money. On the other hand, every year that you wait means more wood at the end. How to decide when to harvest? The tree continues to grow until year 50, when it seems to have reached an equilibrium: perhaps growth goes to zero, or rot balances what growth there is. There’s no point waiting until after year 50. At year 25, the tree is growing as fast as it ever will. You’ll get about 600 board-feet of lumber. Should you harvest at year 25? No! That the tree is growing so fast means that you will have a lot more wood at year 26, 27, and so on. The time to harvest is when the growth is getting smaller, so that it’s not worth waiting an extra year. The quantity of interest is the average rate of growth from seedling to harvest. Harvesting at year 25 will give a total change of 600 board feet over 25 years, giving an average rate of change of \\(600 \\div 25 = 24 \\mbox{board-feet-per-year}\\). But if you wait until year 35, you’ll have about 900 board feet, giving an average rate of change of $900 = 25.7 . We’ve been presenting the average rate of change as a number: \\[\\frac{f(t_B) - f(t_A)}{t_B - t_A}\\] But it’s helpful to think of it as a function that takes two inputs, which we can call \\(t_A\\) and \\(t_B\\): \\[\\mbox{ave\\_rate\\_of\\_change}(t_A, t_B) \\equiv \\frac{f(t_B) - f(t_A)}{t_B - t_A}\\] This is a very subtle maneuver. The formula is exactly the same, but by writing the quantities \\(t_A\\) and \\(t_B\\) as inputs (by putting them in parentheses on the left side), we turn the formula into a function. Sometimes the average-rate-of-change function presents the information in a clear way. Back to the forest … Here’s a graph of the average-rate-of change function. The function has two inputs, but botany dictates that we can only be growing word from the time the seedling is planted. So we’ll set \\(t_A = 0\\) and look at the corresponding slice of the function: The graph makes it clear that the maximum average growth from planting to harvest will occur at about year 32. 6.2 Instantaneous rate of change [Deriv-2b] Distinguish the “average rate of change” from the “instantaneous rate of change.” The car’s speedometer shows the speed at each moment—or instant—of the trip. As you can see in Figure @ref{fig:stop-and-go}, the speed varies and is sometimes less than the average speed, sometimes greater, and occasionally equal to the average speed over the trip. The general term for the kind of quantity presented by the speedometer is the instantaneous rate of change of the position function with respect to the input to that function. Figure @ref{fig:instant-speed} shows the instantaneous rate of change of position with respect to time. The two graphs in Figures @ref{fig:stop-and-go} and @ref{fig:instant-speed} show exactly the same car trip. The presentation of the data in the different graphs makes it easy to see some things and hard to see others. For instance, figuring out when the car is at a stand-still is harder in the position-vs-time graph than in the speed-vs-time graph. This is very much in the spirit of the sand-furrows example at the start of this chapter: it’s much easier to perceive the furrows because the lighting highlights areas sloping toward the sun as bright and areas sloping away from the sun as dark. In Figure @ref{fig:instant-speed} we’re not using light-and-dark for the display. Instead, we’re showing the instantaneous speed as the vertical position Recall that the interval between \\(t_B\\) and \\(t_C\\) had an average rate of change of about 39 miles-per-hour. Looking at the instantaneous rate of change tells the story differently: at time \\(t_B\\) the car was accelerating to about 60 miles-per-hour. Then it gradually slowed, coming to a stop just before time \\(t_C\\). Figure @ref{fig:stop-and-go} shows the function \\(\\mbox{position}(t)\\). Figure @ref{fig:instant-speed} shows a different function, \\(\\mbox{speed}(t)\\). Although the two functions are different, they are intimately related: \\(\\mbox{speed}(t)\\) is the instantaneous rate of change of \\(\\mbox{position}(t)\\). Two central operations in calculus are: Given a function \\(f(t)\\), find the function \\(g(t)\\) giving the instantaneous rate of change of \\(f()\\). This process of deriving \\(g(t)\\) from \\(f(t)\\) is called differentiation. Given a function \\(g(t)\\), find the \\(f(t)\\) of which \\(g(t)\\) is the instantaneous rate of change. This process of finding \\(f()\\) given \\(g()\\) is called anti-differentiation. YOU WERE WORKING HERE. Sometimes, working with the average-rate-of-growth function directly tells you what you need. Other times, you need to extend your model. Between year 30 and 32, there is hardly any change in the value of the average-rate-of-change function. It’s increasing a little, but is it really worthwhile to wait. One argument is that at year 29 you already have a valuable resource: wood that could be money in the bank. If the money were in the bank, you could invest it and earn more money and at the same time get a new seedling in the ground to start its growth. You’re doing two things at once. Efficient! To know what is the best year for harvest from this point of view, you want to calculate the effective “interest rate” on the present amount of wood that you earn in the form of new wood. That interest rate is the "],["instantaneous-rate-of-change-1.html", "Chapter 7 Instantaneous rate of change 7.1 From average to instant 7.2 The \\(h\\) framework 7.3 The derivative operator 7.4 Evanescent \\(h\\) 7.5 The \\(\\Delta\\) operator", " Chapter 7 Instantaneous rate of change 7.1 From average to instant YOU HAVE KNOWN HOW TO CALCULATE AN AVERAGE RATE OF CHANGE for a long time. But possibly you don’t yet fully know what the use of such a calculation is other than to help you pass a math test. In this section, we’re going to show how to calculate the instantaneous rate of change function and show some of the many things this is useful for. To orient you to what’s going to happen … We’re going to set up the familiar average-rate-of-change calculation in a new framework. Using that framework, you’ll be able to calculate an average-rate-of-change function. Then, by turning a knob on the calculation in (2), you’ll be able to calculate the instantaneous rate of change function. By the way, the knob is called \\(h\\). In short, this section will introduce you to the operation called differentiation. 7.2 The \\(h\\) framework Calculating an average rate of change involved specifying an interval of the function domain: the left side \\(t_A\\) and the right side \\(t_B\\). Let’s change this notation a little: Left endpoint of domain: \\(t_0\\) Right endpoint of domain: \\(t_0 + h\\) There is nothing fundamentally new here. The interval is still specified by two numbers, but now they are called \\(t_0\\) and \\(h\\). The width of the interval is just \\(h\\), which is a little easier to write than \\(t_B - t_A\\), but is still just the width. The average rate of change in the new notation is \\[\\frac{f(t_0 + h) - f(t_0)}{h}\\ \\ \\mbox{rather than}\\ \\ \\frac{f(t_B) - f(t_A)}{t_B - t_A}\\] Why are you using \\(t\\) instead of \\(x\\)? Remember, the name of an input can be anything at all so long as you use it consistently on the left side of \\(\\equiv\\) and on the right side. All of these are the same definition: \\[g(t) \\equiv e^{kt},\\ \\ g(x) \\equiv e^{kx},\\ \\ g(y) \\equiv e^{ky},\\ \\ g(\\mbox{altitude}) \\equiv e^{k\\,{\\small{\\text{altitude}}}}\\] When we work with functions of two or more variables, it will be essential to give easily distinguished names to the inputs. We’re trying to get you in the habit of paying attention to the names of inputs and break a bad habit from high-school math of calling the input \\(x\\) and the output \\(y\\). Now we are going to make a small, subtle, and important change. Instead of thinking of the average rate of change at a specific interval \\(t_0\\) to \\(t_0 + h\\), we’re going to write an average-rate-of-change function. And since we’re in the habit of giving names to functions, we’ll be careful to name average-rate-of-change functions in a way that makes explicit the connection to the function \\(f(t)\\) whose rate of change is being calculated. Our convention will be to use two additional components in the names of average-rate-of-change functions. The first component is to lead with a “D” in a caligraphic font: \\(\\cal D\\). The second component will be the name of the input whose interval is being used in calculating the rate of change. So … \\[{\\cal D}_t\\, f(t) \\equiv \\frac{f(t + h) - f(t)}{h}\\] You can pronounce \\({\\cal D}_t\\) as “difference with respect to \\(t\\).” But remember that the function name is the whole deal, \\({\\cal D}_t\\, f()\\), which is to be read as “difference with respect to \\(t\\) of \\(f()\\).” Admittedly a long name. Don’t be surprised later when we start using nicknames like Liz (for Elizabeth) or Bill (for William). For instance, later we’ll save ink and breath by using the nickname \\(\\dot{f}()\\) instead of \\({\\cal D}_t\\, f()\\). FOLLOWING NEEDS TO BE SORTED OUT … From the way we’ve defined \\({\\cal D}_t f(t)\\), it’s reasonable to assume that \\(h\\) is a parameter: a symbol naming a numerical value that has to be specified before \\({\\cal D}_t\\, f(t)\\) can be evaluated at a specific \\(t\\). Find an average-rate-of-change function with respect to \\(x\\) of \\(g(x) \\equiv x^2\\). \\[{\\cal D}_x g(x) = \\frac{(x + h)^2 - x^2}{h}\\\\ = \\frac{x^2 + 2 x h + h^2 - x^2}{h}\\\\ = \\frac{2 x h + h^2}{h} = 2 x + h\\] I like to think of \\(h\\) as a kind of tire iron, a small tool used to stretch the bead of a bicycle tire in order to pull it over the wheel rim. Figure 7.1: A tire iron in use Once the tire iron has done its job, it’s removed and you would never know that it was ever there (except that the tire is now successfully mounted on the wheel). Find an average-rate-of-change function with respect to \\(x\\) of \\(g(x) \\equiv x^2\\), but remove the tire iron \\(h\\) when you’re done. \\[{\\cal D}_x g(x) = \\frac{(x + h)^2 - x^2}{h}\\ \\ \\mbox{stretch $x$ a bit}\\\\ = \\frac{x^2 + 2 x h + h^2 - x^2}{h}\\ \\ \\mbox{pull over rim}\\\\ = \\frac{2 x h + h^2}{h} \\ \\ \\mbox{still pulling ...}\\\\ = 2 x + h \\ \\ \\mbox{success!}\\] Now remove the tire iron to get \\[{\\cal D}_x g(x) = 2x\\]. But this is calculus, not bicycle mechanics. How do we know that removing the tire iron isn’t damaging the mathematical wheel? Historically, this has been a serious debate, resolved only with great difficulty more than a century after calculus started being used successfully. Still in the spirit of having fun, let’s try a more serious metaphor… imagining \\(h\\) is actually a central character in a calculus play. The character \\(h\\) is in the middle of the story but never appears in the play, like the missing character Godot in the famous play Waiting for Godot. We said that \\(h\\) in the finite rate of change function \\({\\cal D}_x g()\\), so long as \\(h\\) is small, plays both a central role and has hardly any effect. An economizing director re-writes the play to take \\(h\\) out of it, setting \\(h=0\\): a non-speaking, offstage role. We’ve already seen using legitimate algebra that \\[{\\cal D}_x g(x) = 2 x + h\\] Re-writing by replacing \\(h\\) with 0 streamlines the play, turning \\(\\Delta g()\\) from a dialog involving both \\(x\\) and \\(h\\) into a monologue with \\(h\\) absent: \\[{\\cal D}_x g(x) = 2 x\\]. Simple. And yet … the director gets a letter from the Bit Players Union. We observe that you have eliminated the role of \\(h\\) in the final production version of \\({\\cal D}_x g(x)\\). This is a violation of Union regulations. Recall that the rate-of-change function \\({\\cal D}_x g(x)\\) is defined as a ratio: \\[{\\cal D}_x g(x) \\equiv \\frac{g(x+h) - g(x)}{h}\\] Although the name \\(h\\) does not need to appear in the argument list of \\({\\cal D}_x g(x)\\), eliminating \\(h\\) entirely by replacing her with zero is a division by zero error forbidden by Article 3.16§B¶2 of the Unified Laws of Arithmetic. We ask that you comply with this Article by re-instating the role of \\(h\\) in all evaluations of \\({\\cal D} g(x)\\). Reading this, the director calls her lawyer. Is there a loophole for removing \\(h\\) without breaking the mathematical prohibition on dividing by zero? 7.3 The derivative operator Let’s put aside for the moment the issue of the disappearing \\(h\\). Historically, such “putting aside” has incurred a great deal of criticism. In 1734, famous philosopher George Berkeley (1685-1753) published a long-titled book: The Analyst: A Discourse Addressed to an Infidel Mathematician: Wherein It Is Examined Whether the Object, Principles, and Inferences of the Modern Analysis Are More Distinctly Conceived, or More Evidently Deduced, Than Religious Mysteries and Points of Faith. In The Analyst, Berkeley took issue with the arguments of that time that it is legitimate to divide by \\(h\\) when, ultimately, \\(h\\) will be replaced by zero. Calling \\(h\\) an “evanescent increment,” he asked, “And what are these same evanescent Increments? They are neither finite Quantities nor Quantities infinitely small, nor yet nothing. May we not call them the ghosts of departed quantities?” Interesting, Berkeley believed that the ghost of \\(h\\) yielded correct results. His objection was that the framers of calculus had made two, canceling errors. “[B]y virtue of a two fold mistake you arrive, though not at science, yet truth.” Berkeley was saying that calculus had not yet been put on a solid logical foundation. It was more than a century after Berkeley’s death that this work was accomplished. Once accomplished, the results that had been claimed true all along were confirmed. I propose that we start with the results, which is what everyone uses. Later, we can introduce the new concepts on which the new logic was based. The names of the concepts—continuity, smoothness, singularity—are widely and effectively used in talking about functions, but the names, like many words in English, can be put to good and accurate use without memorizing the precise definitions. On to the results … Every “smooth” function \\(h(x)\\) has a corresponding function that is its derivative \\(\\partial_x h(x)\\). Finding the algorithm for \\(\\partial_x h(x)\\), called differentiating \\(h()\\), is automatic in the sense that it can be done by computer without human intervention or judgment. When there is an algebraic formula for \\(h(x)\\), the computer can find the algebraic formula for \\(\\partial_x h(x)\\). This is called symbolic differentiation. When there is no algebraic formula for \\(h()\\), the computer can use numerical differentiation which involves a non-zero \\(h\\). The results of numerical differentiation on functions with formulas can differ subtly from the results from symbolic differentiation. Usually the difference is too small to notice, but in extreme cases it is not. It’s important for the user of numerical differentiation to know how to identify extreme cases and deal with them. YOU WERE HERE. Often, we use a function so briefly that it’s not worth naming. For instance, rather than saying “Consider the function \\(h(x) = \\sin(2\\pi x/P)\\) and the corresponding average rate of change function \\({\\cal D}_x h(x)\\) …” We’ll write: \\({\\cal D}_x [\\sin(2\\pi x/P)]\\) 7.4 Evanescent \\(h\\) The word “evanescent” means, “lasting for only a short time, then disappearing quickly and being forgotten.” (Source) Another dictionary definition is “tending to vanish like vapor.” (Source) I’ve used metaphors for \\(h\\): tire irons, dramatic characters who never appear or speak. Here’s another one: the solvent in ink or paint. Ink and paint are liquid yet become solid when brushed on a surface. This can happen because the solid pigments are suspended in liquid. Exposed to the air, the liquid vaporizes and is forgotten. The solid pigment remains on the surface. We can easily evaluate an average rate of change function, for instance \\({\\cal D}_t g(t)\\) by evaluating \\(g(t)\\) at two different inputs and dividing by the distance between the inputs: \\[{\\cal D}_t g(t) = \\frac{g(t+h) - g(t)}{h}\\] So if you know \\(g()\\), you know \\({\\cal D}_t g(t)\\). By making \\(h\\) very small, the “average” starts to look like “instantaneous.” Over a small interval of length \\(h\\), every smooth function looks like a straight line. For a straight line, the average rate of change is exactly the same as the instantaneous rate of change. We’d like to take \\(h\\) out of the picture, imagining that it is zero but not dealing with “divide by zero” if we can avoid it. To signify this idea of neglecting \\(h\\), we’ll use a new notation. Rather than \\({\\cal D}_t g(t)\\) which has that pesky \\(h\\) in it, we’ll write \\(\\partial_t g(t)\\), using the lower-case \\(\\partial\\). The function \\(\\partial_t g(t)\\) can properly be called the instantaneous rate of change of \\(g(t)\\). But everyone calls it the derivative of \\(g(t)\\) with respect to \\(t\\) Many people leave out the “with respect to” part, which I suppose is fine for a function like \\(g(t)\\) which has only one input. But functions constructed in modeling generally have multiple inputs, so it’s a bad habit to neglect to identify which one the derivative is “with respect to.” We’ll always sneak the “with respect to” by putting the little subscript on \\(\\partial_t\\). We lose something by letting \\(h\\) vaporize. There is an easy formula for \\({\\cal D}_t g(t)\\), but without \\(h\\) we can’t write down such a formula for the derivative. Mathematicians like to bridge the gap between \\({\\cal D}\\) and \\(\\partial\\), that is between average and instantaneous rates of change, by writing the formula for the derivative with a little “caution” sign out front. \\[\\partial_t g(t) = \\lim_{h\\rightarrow 0} \\frac{g(t+h) - g(t)}{h}\\] The caution sign is mysterious to newcomers because it is saying something absurd: “Remember to forget \\(h\\).” There are people who do actual calculations with \\(\\lim_{h\\rightarrow 0}\\) but nobody needs to any more unless they invent a brand-new function that can’t be written with existing functions. If you do happen to invent such a brand-new function, please remember that you should also invent the derivative of that function. Fortunately for us, the inventors of the past have done the work for us. Here’s a list of what they found for the mathematical functions that underlie our basic modeling functions: \\(\\partial_x e^x = e^x\\) \\(\\partial_x x^0 = 0\\) \\(\\partial_x x^p = p\\, x^{p-1}\\). unless \\(p=0\\). \\(\\partial_x \\sin(x) = \\cos(x)\\) \\(\\partial_x \\cos(x) = -\\sin(x)\\) \\(\\partial_x \\mbox{sigmoid}(x) = \\mbox{hump}(x)\\) We’re going to leave \\(\\partial_x \\mbox{hump}(x)\\) alone for now until we have a more complete understanding of derivatives. But other than that, notice that the derivative of every one of these mathematical functions—exponential, power-law, sinusoid—is also in the set of the basic functions. How can we know that these formulas are right? Let’s start by comparing them to the functions computed from the \\({\\cal D}_x\\) formula when \\(h\\) is very small. Consider \\(\\partial_x e^x\\), which is claimed to be \\(e^x\\). Figure @ref{fig:exp-h} plots \\(e^x\\) (in green) as well as a function ARC\\((x, h)\\) (Average Rate of Change) that takes both \\(x\\) and \\(h\\) as inputs: \\[\\mbox{ARC}(x, h) \\equiv {\\cal D}_x e^x = \\frac{e^{x+h} - e^x}{h} = e^x \\frac{e^h - 1}{h}\\] You can see at a glance that \\(\\mbox{ARC}(x, h)\\) gets closer and closer to the claimed derivative, \\(e^x\\), as \\(h\\) gets smaller. A better view of things comes from recognizing that \\[\\mbox{ARC}(x, h) = e^x \\left[\\frac{e^h - 1}{h}\\right]\\] Let’s look at the quantity in brackets as \\(h\\) gets small. If that goes to 1 for small \\(h\\), then \\(\\mbox{ARC}(x, h)\\) goes to \\(e^x\\). \\(h\\) \\(\\frac{e^h - 1}{h}\\) 1 1.71828182845905 0.1 1.05170918075648 0.01 1.00501670841679 0.001 1.00050016670838 0.0001 1.00005000166714 0.00001 1.00000500000696 0.000001 1.00000049996218 0.0000001 1.00000004943368 0.00000001 0.999999993922529 0.000000001 1.00000008274037 NEXT STEP. The linear expansion … \\(f(x + h) \\approx f(x) + h \\partial_x f(x)\\) D f(g(x)) = f(g(x+h)) - f(g(x)) = f How we When we are interested in an instantaneous rate of change function, YOU GOT HERE. 7.5 The \\(\\Delta\\) operator CHANGE THIS TO \\({\\cal D}\\) and introduce it once you have gotten rid of \\(h\\). Up until now, we used only functions that take numerical quantities as inputs and produce a numerical quantity as an output. It’s time now to broaden our perspective a bit. Imagine a function named \\(\\Delta()\\) defined like this: \\[\\Delta(f) \\equiv \\frac{f(x+h) - f(x)}{h}\\] \\(\\Delta()\\) takes as input a function. You might have guessed this because the definition uses the name \\(f\\) for the input to \\(\\Delta()\\), but the name of an input does not matter so long as it is used consistently in the body of the function. Looking at the body, you can that the name \\(f\\) is being used (twice!) in the position of a function’s name. For instance: \\(\\Delta(\\sin) = \\frac{\\sin(x+h) - \\sin(x)}{h}\\) \\(\\Delta(x^2) = \\frac{(x+h)^2 - x^2}{h}\\) \\(\\Delta(a + b x) = \\frac{a + b(x + h) - \\left(a + b x\\right)}{h}\\) Why did you use \\(=\\) in the above statements rather than the \\(\\equiv\\) ? \\(\\equiv\\) means “is defined as” or “is the name of.” When we wrote \\[\\Delta(f) \\equiv \\frac{f(x+h) - f(x)}{h}\\] we were giving a name to a function. But writing \\(\\Delta(a + b x)\\) means to apply the already defined function \\(\\Delta\\) to an input, that input being the straight-line function \\(a + b x\\). Rather than defining what is \\(\\Delta(a + b x)\\) we are deducing it from objects that have already been defined. What is the output of \\(\\Delta()\\)? It takes a function as an input and returns … a function as an output. We might choose to give a name to the output, for example fred() or betty() or, more helpfully, \\(\\mbox{rate}_{\\sin}\\) or \\(\\Delta \\sin\\), but our naming conventions, particularly the use of \\(x\\) indicate that \\(\\frac{\\sin(x+h) - \\sin(x)}{h}\\) is a function. In calculus, there are a handful of celebrity functions that take a function as input and return a function as output. Notice that the word “function” appeared three times in the previous sentence. To avoid this sort of sleep-inducing repetition, we’ll call such functions operators. An operator (as we will use the word) is a function that, like all functions, has an input and an output. The input is itself a function, the output is also a function, typically (but not always) different from the input. [Diff-1a] Understand the relations between position, velocity, and acceleration as “change relations.” "],["difference-and-change.html", "Chapter 8 Difference and change", " Chapter 8 Difference and change Readings: 347-360 Objectives: #. (Deriv-1b) Know how to calculate the value at a single point of a derivative function. #. (Deriv-1c) Understand that differentiation is an operator that produces a function called the derivative. ROUGH ROUGH ROUGH Lidar measured distance to ground. The function value doesn’t really matter. What matters is how the value at a point relates to the values at nearby points. Seeing this difference is how you can spot the Maya ruins. Instituto Nacional de Estadística y Geografía/Nacional Center for Airborne Laser Mapping \"The map, published in 2011 by Mexico’s National Institute of Statistics and Geography, covered 4,440 square miles in the Mexican states of Tabasco and Chiapas. It was made as part of the institute’s mission to create accurate maps to be used by businesses and researchers. “Dr. Inomata learned about the map from Rodrigo Liendo, an archaeologist at the National Autonomous University of Mexico. The resolution of the map was low. But the outlines of countless archaeological sites stood out to Dr. Inomata. So far, he has used it to identify the ruins of 27 previously unknown Maya ceremonial centers that contain a type of construction that archaeologists had never seen before. These sites may hold insights into the origins of Maya civilization.” NYTimes article "]]
