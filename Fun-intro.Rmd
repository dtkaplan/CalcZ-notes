# (PART) Block 1: Functions and quantity {.unnumbered}

Give an overview here.
 
# What is a function?

::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-10", 
text="Objective Original: Understand the relationship between inputs and outputs for functions of one or two input variables, to include functions defined piecewise.
**Objective Revised**: Recognize that functions are a way of representing (storing) what we know and be able to use properly the basic nomenclature of functions).")
```
:::


People have many ways of organizing what they know. Often we rely on our intuitive abilities of memory, but we also have constructed frameworks to make the storage more accessible and reliable. One of these frameworks is the ***table***, generally set up as an array of rows and columns. For instance, here is a table about a range of internal combustion engines of various sizes:

```{r}
DT::datatable(Engines)
```

Each row of the table reports on one, specific engine. Each column is one attribute of the of an engine. Using such tables can be easy. For example, if asked to report how fast the engine named "Enya 60-4C" spins, you would go down to the Enya 60-4C row and over to the "RPM" column and read off the answer: 11,800 revolutions per minute (RPM).

A table like this can be said to describe as raw numbers the general relationships between various engine attributes. For instance, we might want to understand the relationship (if any) between RPM and engine mass, or relate the number and diameter (that is, "bore") and depth (that is, "stroke") of the cylinders to the power generated by the engine. Any single entry in the table doesn't tell us about such general relationships; we need to consider the rows and columns as a whole.

If you examined the relationship between engine power and cylinder number, diameter, and depth, you will find that (as a rule) the larger the number, diameter, and depth, the more powerful the engine. That's a ***qualitative*** description of the relationship. Most educated people are able to understand such a quantitative description. Even if they don't know exactly what "power" means, they have some rough conception of it. And almost everyone knows what diameter, depth, and number mean.

Often, we're interested in having a ***quantitative*** description of a relationship such as the one (number, diameter, depth) $\rightarrow$ power. Remarkably, the many of educated people are uncomfortable with the idea of using quantitative descriptions of a relationship: what sort of language the description should be written with; how to perform the calculations to use the description; how to translate between data (such as in the table) and a quantitative description; how to translate the quantitative description to address a particular question or make a decision.

This course is about constructing and using such quantitative descriptions, which we'll call ***mathematical models***. Skills for doing this are essential for work in engineering and science, and highly valued in many other fields in commerce, management, and government. Often, the work of applying such quantitative skills is called ***calculation***. The name ***calculus*** is used to describe the methods that are widely used for undertaking calculations.

***Functions*** are a fundamental way of organizing mathematical models and calculations. You have undoubtedly seen them in your previous mathematics education, but it's worth reviewing them from the basics so that we can share a vocabulary for communicating about them. 

- A function is a transformation from one or more ***inputs*** to an ***output***. 
- To keep things simple for now we'll focus on inputs and outputs that are ***numeric***, but later we'll need a more nuanced view of "numeric" that takes into account the different kinds of things that are represented by numbers, e.g. length, power, RPM.

To see how functions work, imagine a long corridor with a sequence of offices, each identified by a room number. The input to the function is the room number. To ***evaluate*** the function for that input, you knock on the appropriate door and, in response, you'll receive a piece of paper with a number to take away with you. That number is the output of the function.

This will sound at first too simple to be true, but ... In a mathematical function each office gives out exactly the same number every time someone knocks on the door. Obviously, being a worker in such an office is highly tedious and requires no special skill. Every time someone knocks on the worker's door, he or she writes down the *same* number on a piece of paper and hands it to the person knocking. What that person will do with the number is of absolutely no concern to the office worker.

The utility of such functions depends on the artistry and insight of the person who creates them: the ***modeler***. An important point of this course is to teach you some of that artistry. Hopefully you will learn through that artistry to translate your insight to the creation of functions that are useful in your own work. But even if you just use functions created by others, knowing how functions are built will be helpful in using them properly.

In the sort of function just described, all the offices were along a single corridor. Such functions are said to have ***one input***, or, equivalently, to be ***functions of one variable***. To operate the function, you just need one number: the address of the office from which you'll collect the output.

Many functions have more than one input: two, three, four, ... tens, hundreds, thousands, millions, .... In this course, we'll work mainly with functions of two inputs, but the skills you develop will be applicable to functions of more than two inputs.

What does a function of two inputs look like in our office metaphor? Imagine that the office building has many parallel corridors, each with a numeric ID. To evaluate the function, you need two numeric inputs: the number of the corridor and the number of the door along that corridor. With those two numbers in hand, you locate the appropriate door, knock on it and receive the output number in return.

Three inputs? Think of a building with many floors, each floor having many parallel corridors, each corridor having many offices in sequence. Now you need three numbers to identify a particular office: floor, corridor, and door. 

Four inputs? A street with many three-input functions along it. Five inputs? A city with many parallel four-input streets. And on and on.

Applying inputs to a function in order to receive an output is only a small part of most calculations. Calculations are usually organized as ***algorithms***, which is just to say that algorithms are descriptions of a calculation. The calculation itself is ... a function! 

How does the calculation work? Think of it as a business. People come to your business with one or more inputs. You take the inputs and, following a carefully designed protocol, hand them out to your staff, perhaps duplicating some or doing some simple arithmetic with them to create a new number. Thus equipped with the relevant numbers, each member of staff goes off to evaluate a particular function with those numbers. (That is, the staff member goes to the appropriate street, building, floor, corridor, and door, returning with the number provided at that office.) The staff re-assembles at your roadside stand, you do some sorting out of the numbers they have returned with, again following a strict protocol. Perhaps you combine the new numbers with the ones you were originally given as inputs. In any event, you send your staff out with their new instructions---each person's instructions consist simply of a set of inputs which they head out to evaluate and return to you. At some point, perhaps after many such cycles, perhaps after just one, you are able to combine the numbers that you've assembled into a single result: a number that you return to the person who came to your business in the first place. 

A calculation might involve just one function evaluation, or involve a chain of them that sends workers buzzing around the city and visiting other businesses that in turn activate their own staff who add to the urban tumult.

As you know, there is a powerful way of thinking about numbers in terms of ***space*** and ***geometry***. For instance, a single number corresponds to a point on a line: the so-called ***number line***. A pair of inputs, say, (x, y) corresponds to a point in a plane, often called the ***Cartesian coordinate plane***. Three numbers corresponds to a point in space, perhaps organized into (x, y, z) of a Cartesian space. There are higher-dimensional spaces, but usually special training is needed to become comfortable with them. If you are having this discomfort, you might prefer to work with the office metaphor. Just for fun, here's how you can think of a 10-dimensional space: 10 numbers, one telling you which planet, the next specifying the continent on that planet, and so on for country, state, city, street, building, floor, corridor, door.

The set of inputs with which the function can be evaluated is called the ***domain*** of the function. Sometimes we describe the domain as a space, e.g. the number line, the plane, and so on. Sometimes domains including more restrictions. For instance, a particular input might only meaningfully be positive, with no offices corresponding to negative values for that input. Or, an input might be restricted to be in the interval 0 to 1. Sometimes in calculus, the domain excludes an isolated point. For instance, there may be no office at the door marked 0 but the neighboring doors open into working offices.

The ***range*** of a function is the set of all the *outputs* that can be produced. Since at this stage we're working only with functions that return a single number as output, it's common to describe the range as all or part of the number line. For instance, some functions only have positive outputs. Other functions' outputs are always in the interval 0 to 1. (This is the case, for instance, when the function returns a probability as the output.)

::: {.worked-example data-latex=""}
**Weather forecasting by numerical process**

*[Weather forecasting by numerical process](https://archive.org/details/weatherpredictio00richrich/page/184/mode/2up?view=theater)* is a highly influential book, from 1922, by [Lewis Fry Richardson](https://en.wikipedia.org/wiki/Lewis_Fry_Richardson). He envisioned a calculation for a weather forecast as a kind of function. The domain for the forecast is the latitude and longitude of a point on the globe, rather than the rectilinear organization of corridor. 

One fantastic illustration of the idea shows a building constructed in the form of an inside-out globe. At each of many points on the globe, there is a business. (You can see this most clearly in the foreground, which shows several boxes of workers.)

```{r echo=FALSE, out.width="70%", fig.align="center", fig.cap="An artist's depiction of the organization of calculations for weather forecasting by Richardson's system. [Source](https://www.cabinetmagazine.org/issues/27/foer.php)"}
knitr::include_graphics(normalizePath("www/Richardson-globe.jpg"))
```

Each business might work this way: In each business there is a person who will report the current air pressure at that point on the globe, another person who reports the temperature, another reporting humidity, and so on. To compute the predicted weather for the next day, the business has a staff assigned to visit the neighboring businesses to find out the pressure, temperature, humidity, etc. Still other staffers take the collected output from the neighbors and carry out the arithmetic to translate those outputs into the forecast for tomorrow. For instance, knowing the pressure at neighboring points enables the direction of wind to be calculated, thus the humidity and temperature of air coming in to and out of the region the business handles. In today's numerical weather prediction models, the globe is divided very finely by latitude, longitude, and altitude, and software handles both the storage of present conditions and the calculation from that of the future a few minutes later. Repeating the process using the forecast enables a prediction to be made for a few minutes after that, and so on.

Some of the most important concepts in calculus relate to the process of collecting outputs from neighboring points and combining them: for instance finding the difference or the sum. To illustrate, here is the first set of equations from Richardson's *Weather forecasting ...*, writen in the notation of calculus:

```{r echo=FALSE, out.width="70%", fig.align="center"}
knitr::include_graphics(normalizePath("www/Richardson-equations.png"))
```

You can hardly be expected at this point to understand the calculations described by these equations, which involve the physics of air flow, the coriolis force, etc. but it's worth pointing out some of the notation:

- The equations are about the momentum of a column of air at a particular latitude ($\phi$) and longitude.
- $M_E$ and $M_N$ are east-west and north-south components of that momentum. 
- $\partial M_E /\partial t$ is the amount the east-west momentum will change in the next small interval of time ($\partial t$).
- $p_G$ is the air pressure at ground level from that column of air. 
- $\partial p_G / \partial n$ is about the difference between air pressure in the column of air and the columns to the north and south.

Calculus provides both the notation for describing the physics of climate and the means to translate this physics into arithmetic calculation.

:::

# Graphs & Graphics

## The mathematical graph

::: {.objectives data-latex=""}

```{r echo=FALSE, results="asis"}
state_objective("F-20", "Understand that a mathematical graph consists of points in a composite space: the input $\times$ output.")
```

:::

Needless to say, we won't be implementing functions by building cities of multi-floor office buildings. Instead, we'll have a variety of implementations that take different forms. We'll start with two:

- ***Graphs***: a form of representation that lets you evaluate a function by eye.
- ***Formulas***: another form of representation that gives the instructions for evaluating a function using arithmetic (and other functions).

***Scientific and statistical graphics*** are visual depictions of information and data. Mathematicians favor a particular style of graphics for representing functions with one or two inputs. This favored style is called a ***function graph***, which has a specific technical meaning in mathematics.

In a function graph, the frame---a region on a piece of paper or other display---is a coordinate grid. Every position on the grid is represented by both the inputs to the function and the output from the function. For instance, for a function with one input, the frame is often the Cartesian coordinate plane, like this:

```{r echo=FALSE}
gf_blank(mpg ~ wt, data=mtcars) %>% 
  gf_labs(y = "Output", x = "Input") %>%
  gf_lims(y = c(-20,20), x=c(-5, 5))
```

This graphics frame is not yet a mathematical graph. It's merely the field on which the graph will be drawn. One axis represents the input to the function. The other axis represents the output from the function. 

The graph shows the output for each individual input. That is, it is a series of points marking the level of the output for each given input. In our office metaphor for functions, the input is the number on the office door. But here the door numbers are not just integers (like 2) but any number on the number line (like 2.718282). So the points marked form a continuous curve, like this:

```{r echo=FALSE}
f1 <- rfun(~ x, seed=931)
slice_plot(4*f1(x) + 25 ~ x, domain(x=c(-5, 5))) %>% 
  gf_labs(y = "Output", x = "Input") %>%
  gf_lims(y = c(-20,20), x=c(-5, 5))
```

You can easily evaluate a function for a given input from its graph. As you know, just put your finger at the horizontal coordinate for the input. Then move your finger upward to reach the point on the curve directly above that horizontal coordinate. You read off the value of the function at that input by reference to the scale on the vertical axis.

Graphs are relatively modern, coming into mainstream use only in the 1700s. Much of mathematics was developed before graphs were invented. One consequence of this is that function tasks that are easy using a graph might be very hard with the previous ways of implementing functions. This is analogous to the way that arithmetic is pretty easy with Arabic numerals, but really hard with Roman numerals.

It's not possible to show with a graph the whole of a function whose domain is $-\infty$ to $\infty$. Consequently, when drawing a graph we choose to show only that part of the domain that we expect will be relevant to our needs.

Sometimes, the graphic's domain includes parts that are not in the domain of the function being drawn. In such cases, the function's graph does not extend into the invalid part of the graphic domain, as in this plot of a function whose domain is only the positive numbers.

```{r echo=FALSE, warning=FALSE, message=FALSE}
slice_plot(log(x) ~ x, domain(x=c(-5, 5)), npts=500) %>% 
  gf_labs(y = "Output", x = "Input") %>%
  gf_lims(y = c(-3,3), x=c(-5, 5)) 
```

This function has a range that runs from $-\infty$ to $\infty$, but the limits of paper and display mean that we can show only part of this range. With experience, you'll learn to read the hints in a graph that the underlying function might have a range larger than the one shown in the graphic.

We can also draw graphs of functions with two inputs. Now the points need to be marked in a 3-dimensional space: one axis for each of the two inputs and another axis for the output. Like this:

```{r echo=FALSE, fig.cap="(Figure Fun-1b-1.2)"}
f2 <- rfun( ~ input_1 + input_2, seed=932)
interactive_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)))
```

It is very hard to read a graph of a function with two inputs. Think of the graph as a kind of tent suspended over a domain of ground. The graph itself is a surface. To show the graph on a display, some tricks of the trade are used: color to give an additional scale for the output; computer graphics to let us rotate the surface to look at it from various perspectives, added grid lines and marks on the surface to help us read out the numerical value.

## Contour plots

::: {.objectives latex-data=""}

```{r echo=FALSE, results="asis"}
state_objective("F-21", "Interpret a contour plot of a function of two input variables, to include estimating function values and locations of peaks and valleys.")
```
:::

A mathematical graph is just one way to draw a picture of a function with two inputs. There are other ways. One helpful mode of picture is called a ***contour plot***, familiar to many non-mathematicians in the form of topgraphical maps showing landscape elevation as a function of latitude and longitude. Here's a contour plot of the same function shown in the previous graph:

```{r echo=FALSE, fig.cap="(Fig-1b-2.1)"}
f2 <- rfun( ~ input_1 + input_2, seed=932)
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0)
```

This contour plot is a topographical map of the mathematical graph in Figure Figure (Fun-1b-1.2)

It may take some practice to learn to read contour plots fluently but it is a skill that's worthwhile to have. Note that the graphics frame is the Cartesian space of the two inputs. The output is presented as ***contour lines***. Each contour line has a label giving the numerical value of the function output. Each of the input value pairs on a given contour line corresponds to an output at the level labeling that contour line. To find the output for an input pair that is *not* on a contour line, you ***interpolate*** between the contours on either side of that point. 

For example, the input pair (0, 0)---which is at the bottom of the frame, midway from left to right---falls between the contours labeled "20" and "22." This means that the output corresponding to input (0, 0) is somewhere between 20 and 22. The point is much closer to the contour labeled "20", so it's reasonable to see the output value as 20.5. This is, of course, an approximation, but that's the nature of reading numbers off of graphs.

Often, the specific numerical value at a point is not of primary interest. Instead, we may be interested in how steep the function is at a point, which is indicated by the spacing between contours. When contours are closely spaced, the hillside is steep. Where contours are far apart, the hillside is not steep, perhaps even flat.

Another common task for interpreting contour plots is to locate the input pair that's at a local high point or low point: the top of a hill or the bottom of a hollow. Such points are called ***local argmax*** or ***local argmin*** respectively. The *output* of the function at a local argmax is called the ***local maximum***; similarly for a local argmin, where the output is called a ***local minimum***. (The word "argmax" is a contraction of "argument of the maximum." We will tend to use the word "input" instead of "argument", but it means exactly the same thing to say "the inputs to a function" as to says "the arguments of a function.")

Still other common tasks for reading contour plots are to start at a given input pair and figure out 1) the direction to move which is most steeply uphill, or 2) the direction to move which will keep the function output the same.

It can be helpful to look at a contour map and interpret the contours as representing geographical features: hills, valleys, crests, coves, hollows, and so on. 

Then, for (Fun-1c) translate between a contour plot and a graph of a function with one input. (We can think about this as a function of two inputs, where we hold one of the inputs constant, that is, always the same. )

## Slice plots

::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-23", "Know what is meant by a slice of function of two variables.  Be able to determine if a function is increasing, decreasing, or constant when moving horizontally or vertically on the contour plot.")
```
:::

As mentioned before, ***mathematical modeling*** is the process of constructing mathematical representations of situations or phenomena of interest. In CalcZ, we are primarily interested in using ***functions*** as such representations. 

Almost always, when mathematically modeling a real-world situation or phenomenon, we do not try to capture every nuance of every relationship that might exist in the real world. We leave some things out. Such simplifications make modeling problems tractable and encourage us to identify the most important features of the most important relationships. 

On the other hand, it's easy to go wrong and leave out something that's important. To mitigate this risk, many modeling projects involve a ***modeling cycle*** where we propose a candidate model, examine the consequence of that model to see if it corresponds well to the parts of reality that are important to us in our task, and modify the model as needed to produce a new and better candidate.

In this spirit, it's useful always to assume that our models are leaving something out and that a more complete model involves a function with more inputs than the present candidate. The present candidate model should be considered as a ***slice*** of a more complete model. Our slice leaves out one or more of the variables in a more complete model.

To illustrate this, suppose that we have a "more complete model" in the form of a function of two inputs, as shown in the contour plot below.

```{r (Fig-1c.1), echo=FALSE}
f2 <- rfun( ~ input_1 + input_2, seed=96)
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0)
```

As you become practiced reading contour plots, you might prefer to read this one as a hilltop (shaded yellow) side-by-side with a hollow or bowl (shaded purple), with green, almost level flanks at the left and right edges of the frame.

The most common forms of ***slice*** involve constructing a simpler function that has one input but not the other. For example, our simpler function might ignore input #2. There are different ways of collapsing the function of two inputs into a function of one input. An especially useful way in calculus is to take the two-input function and set one of the inputs to a ***constant value***. 

For instance, suppose we set input #2 to the constant value 1.5. This means that we can consider any value of input #1, but input #2 has been replaced by 1.5. In Figure Fig-1c.2, we've marked in red the points in the contour plot that give the output of the simplified function. 

```{r (Fig-1c.2), echo=FALSE, out.width="50%", fig.show="hold", warning=FALSE}
f2 <- rfun( ~ input_1 + input_2, seed=96)
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0) %>%
  gf_hline(yintercept=1.5, color="red", size=2) %>%
  gf_labs(title="Contour plot of function of two inputs")
slice_plot(f2(input_1, input_2=1.5) ~ input_1, domain(input_1=c(-5, 5))) %>%
  gf_labs(title="Graph of function output versus input #1")
```

Each point along the red line corresponds to a specific value of input #1. From the contours, we can read the output corresponding to each of those values of input #1. This relationship, output versus input #1 can be drawn as a mathematical graph (to the right of the contour plot). Study that graph until you can see how the rising and falling parts of the graph correspond to the contours being crossed by the red line.

Slices can be taken in any direction or even along a curved path! The blue line below the slice constructed by letting input #2 vary and holding input #1 and the constant value 0. 

```{r (Fig-1c.3), echo=FALSE, out.width="50%", fig.show="hold", warning=FALSE}
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0) %>%
  gf_vline(xintercept=0, color="blue", size=2) %>%
  gf_labs(title="Contour plot of function of two inputs")
slice_plot(f2(input_1 = 0 , input_2) ~ input_2, domain(input_2=c(0, 5))) %>%
  gf_labs(title="Graph of function output versus input 2")
```


# Notation for functions

::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-30", "Identify the structure of function notation when the function is defined by a formula.")
```
:::

A graphic such as a contour plot or a mathematical graph can be an excellent way of presenting a function to a human viewer. There are other ways of presenting functions that have other advantages, such as speed of evaluation, computer readability, and the ability to perform computations that ***derive a new function from the original***. If you have studied calculus before, you know the word "derivative," which is all about a particular kind of new function created from an original. We'll get to this in good time along with other ways of "deriving" new functions from old.

Let's look carefully at some formats for organizing the parts of a function.

Consider the function $$g(x) \equiv m x + b$$ You already know:

i. $g()$ is the name we've given to the function. The name is the choice of the modeler. 
ii. $(x)$ indicates that there is one input to $g()$ and that we are going to call this input "$x$". 
    a. The parentheses are simply punctuation.
    b. If we wanted a function with two inputs, we would need two different names inside the parentheses and would separate them with a comma: e.g. $h(x, y) = a_0 + a_x x + a_y y$.
iii. $m x + b$ is a ***formula*** in traditional mathematical notation. So is $a_0 + a_x x + a_y y$. 
    a. Note that there is no equal sign in a formula; a formula is **not** an equation!
    b. The formulas we've seen so far can be evaluated with arithmetic. But often a formula will involve the invocation of another function. For example: $\sqrt{\strut m x + b}$ or $\sin(m x) + \ln(b)$.
    
    
It's helpful to generalize the idea of a formula a bit. An ***algorithm*** is a set of instructions for performing a computation. High-school math typically involves presenting algorithms as formula. You learned, maybe in middle school, how to follow the arithmetic steps involved in algorithms described as formulas. You also have likely used a calculator to perform some of the arithmetic or to evaluate functions such as $\sin()$ and $\ln()$ and $\sqrt{\strut}$ for which you don't know how to evaluate using simple arithmetic. The calculator is implementing an algorithm with which its been programmed to enable the calculation of $\sin()$ and $\ln()$ and such.

Many functions are described by algorithms that use concepts common in computer programming but unknown to traditional mathematical notation. Some of these have names like ***iteration*** or ***branching*** and many refer to stored lists of fixed numbers (like the office workers in the street, building, floor, corridor, door image of a function). We'll deal with some of these things later, but for now ...

> We are going to use the word ***algorithm*** to name the kind of expression to the right of $\equiv$ in a function definition. A ***formula*** is a specific kind of algorithm generally written in traditional math notation.

Algorithms, including the ones that are formulas, are written in terms of a set of ***symbols*** that stand for inputs. This is a high-fallutin' way of saying something simple: in $mx + b$, the $x$, $m$, and $b$ are the names we give to the quantities being used in the calculation.

The notation we are using for function definition lists some of these names in two places, and others in only one place. Again, look at $$g(x) \equiv m x + b$$
The $x$ appears both in the algorithm and the list of input name $(x)$ to the left of $\equiv$.

The $m$ and $b$ are different; they appear **only** in the algorithm. The word for such quantities in mathematics is ***parameter***. Eventually, when the algorithm is followed, we're going to have to put in specific numerical values in place of each parameter. 

**Where will these parameter values come from?** This is a subject on which mathematical notation is silent. You have to figure it out from context and experience. This is potentially very confusing, especially when a human is not around to sort things out.

Fortunately, the notation used in computer programming does not have this flaw. Depending on the language things can be handled in one way or another. For experienced computer programmers: This is the issue of ***scope***. In the software used in CalcZ (R, with the `mosaic` package of extensions), we will take a simple-to-use approach that avoids your having to deal with scope. 

It works like this: 

> All modeling functions we construct with R/`mosaic` will list parameters formally as ***arguments*** to the function.

It is as if we wrote in traditional notation $$g(x, m, b) \equiv m x + b$$

There is also a way to give default numerical values to parameters so that you can write $g(3.5)$ and the computer will know where to find the parameter values. In writing about formulas using math notation, we'll extend the traditional notation to write, for instance, $g(x, m=2, b=3) \equiv m x + b$.

In R/`mosaic`, we would construct a mathematical function like $g()$ using the `makeFun()` function:

```r
g <- makeFun(m*x + b ~ x, m=2, b=3)
```

You could also write 

```r
g <- makeFun(m*x + b ~ x)
```
but this notation means that you will have to give specific numerical values for the `m` and `b` inputs whenever you evaluate `g()`. There won't be any default values for the "parameters-as-inputs" `m` and `b`.

* Relevant Blog post: CalculusBlog/post-formal-arguments.Rmd


::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-31-R", "Identify and create R versions of mathematical functions using `makeFun()` and tilde expressions.")

state_objective("F-32-R", "Use the `slice_plot()`, `contour_plot()`, and `domain()` functions in R/`mosaic`.")
```
:::

::: {.todo}
NOTHING HERE YET
:::

::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-33", "Master the conventions used in CalcZ for giving names to functions and for referring to functions with \"pronouns.\"")
```
:::

We're going to be using a lot of functions in CalcZ. Some of these functions have ***proper names***, usually written using short sequences of letters: for instance $\sin()$, $\ln()$, $\exp()$. 

Other functions will needed just for a sentence or a paragraph or a section, perhaps being used in an example or to lay out the steps of an algorithm. In ***natural languages*** such as English, we often use ***pronouns*** for such purposes: she, he, it, they, we, I, .... We also will use pronouns for identifying functions. Our policy is this:

> A pronoun for a function will be named $f()$ or $g()$ or $h()$ or the corresponding upper-case letters $F()$, $G()$, or $H()$. **The particular choice of letter f, g, or h has no significance whatsoever.** It is just a way to give an unambiguous handle for a function that we are going to be using for a little while. 

On occasion, we will use subscripts or superscripts on these pronoun letters, for instance $f_1()$ or $g^\star()$. This is a way to give us many more possible pronouns when we need them. Perhaps this is analogous to words like "sister," "parent," "husband," "cousin," etc. that allow us to refer, without a proper name, to a specific person.

On other occasions, where a function relates to a specific quantity such as position or velocity, we will use the names $x()$, $y()$, $z()$, $u()$, $v()$, $w()$, and such. These letters are, of course, the same ones we frequently use to name the inputs to functions. How do you know whether the letter is meant to refer to an input rather than a function? That's the point of the parentheses: $x()$ is a function name, $x$ is an input name. 

It can become tedious to give a name to every function, even if it's not being used again. Consider this sentence as an example: 

> "The functions $g(x) \equiv \sqrt{\strut x}$ and $h(x) \equiv x^3$ are examples of power-law functions." 

Long and awkward. So we'll feel free to write instead, 

> "$\sqrt{\strut x}$ and $x^3$ are examples of power-law functions."

Without the formality provided by "$g(x) \equiv$" it can be hard to know whether $\sqrt{\strut x}$ means "the square-root function" or "take the square root of a specific number $x$. The convention we will use is based on the name used in the expression. When standard argument names from the end of the alphabet are being used without any subscript (e.g. $x_0$) or with a special symbol as a subscript (e.g. $t^\star$), we intend the expression to be a function. However, when we want to apply a function to specific values for inputs we will write in any of the following styles:

$$f(x^\star) \ \ \mbox{or}\ \ \sqrt{\strut x^\star}\ \ \mbox{or}\ \ \sqrt{\strut x=3}\ \ \mbox{or}\ \ \left.\sqrt{\strut x}\right|_{x=3}\ \ \mbox{or}\ \ \left.g(x)\strut \right|_{x=3}$$

One of the important techniques of calculus is to take something we often think of as a number and turn it in to a function whose output is a number. It will take you time to get used to the calculus notation and to be able to tell at a glance whether something is a function or a number.

Here's an illustration that will only make sense to those who have already studied some calculus:

$$\int\! f(x) dx \ \ \text{is a function, but}\ \ \int_0^3\! f(x) dx\ \ \text{is a number.}$$

Give yourself a break as you're learning the notation conventions. When you read a mathematical expression, a good first question to ask is, "What kind of thing is this? A function? A number?"


We need such care about notation because, in addition to writing math in traditional mathematics notation (e.g. $e^x$ (which, as the above indicates, is a function) or $\ln(y^\star)$ (which is a number)), we need to be able to convey mathematical ideas to computers. Traditional mathematics notation was developed in the pre-keyboard era (that is, pre-typewriter era) and before the development of computer languages brought to the fore the effectiveness of structuring computing instructions as functions. For reference, here are some R expressions:

1. `f <- makeFun(x^2 ~ x)` defines a function `f()` that the computer can use. It means the same thing to the computer as $f(x) \equiv x^2$ means to the human reader. A ***tilde expression*** such as `x^2 ~ x` is a way of making clear that a symbol (`x` here) stands for the input to a function.
2. `x_pts^2` means to square the particular values stored under the name `x_pts`. To be sure, it's also perfectly valid computer syntax to write `x^2`, since `x` is just as good a name for a computer object as `x_pts`. But we will avoid such use of names like `x`. 
3. For people who are already familiar with R, note that the style `f <- function(x) { x^2 }` is the universally accepted way to write R functions. `{ x^2 }` is the ***body of the function***. (In CalcZ we use `makeFun()` as a kind of shorthand. `makeFun()` is provided by the `{mosaic}` package. 


::: {.todo}
EXERCISES: According to the notation style we use in CalcZ, which of these things is a function? Which a number? 

- $\sqrt{z}$: function 
- $\sqrt{y^\star}$ number 
- $e^{k t}$ function of $t$. The letter $t$ is one of our standard letters for input names. $k$ is a letter, but since it is not from the end of the alphabet, you have a hint that it is intended to be a parameter, that is a symbol representing a specific numerical quantity.
- $g(k) \equiv e^k$ a function of $k$. Notwithstanding our convention that $k$ is not on its own a name used for inputs, when we use the full function-definition style, anything in the parentheses following the function name is explicitly stated as an input name.
:::



