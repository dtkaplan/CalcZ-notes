# Graphics & function graphs {#graphs-and-graphics}

::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-20", "Understand that a mathematical graph consists of points in a composite space: the input $\\times$ output.")
```
:::


***Scientific and statistical graphics*** are visual depictions of information and data. For displaying a function with a single input, mathematicians and other favor a particular style of graphics. This favored style is called a ***function graph***, which has a specific technical meaning in mathematics. Notice that we're writing "function graph" rather than "function graphic." A function graph is a particular sort of graphic: there are many other types of graphics some of which we'll use to display data or features of functions.

## The graphics frame

Technical graphs are usually drawn in a ***graphics frame*** 
that has several components:

1. The ***frame*** is a region on the piece of paper or computer screen that is marked off by a horizontal and a vertical axis.
2. The horizontal axis stands for one quantity.
3. The vertical axis stands for another quantity.
4. Both the horizontal and vertical axes are drawn with a ***scale*** that enables you to translate between a numerical value and position.

```{r empty-frame, echo=FALSE, fig.cap="An empty graphics frame with scales for both the horizontal and vertical axes."}
gf_blank(mpg ~ wt, data=mtcars) %>%
  gf_labs(y = "Vertical", x = "Horizontal") %>%
  gf_lims(y = c(-20,20), x=c(-5, 5))
```

## Data graphics: the point plot

One of the most common uses of a graphics frame is to display visually two columns from a table containing data. For instance, here is a small part of a table about the size of penguins in the Palmer Archipelago in Antarctica.

```{r}
library(palmerpenguins)
set.seed(101)
knitr::kable(
  penguins %>% sample_n(10) %>%
    select(species, body_mass_g, flipper_length_mm, 
           bill_length_mm) %>%
    rename(body_mass = "body_mass_g", 
           flipper_length = "flipper_length_mm",
           bill_length = "bill_length_mm") %>%
    mutate(body_mass = body_mass/1000,
           flipper_length=flipper_length/10,
           bill_length = bill_length/10)
) %>% 
    kableExtra::kable_styling()
```

A point plot displays two columns from the table. Each row in the table is represented by one point in the graphic. For instance:

```{r echo=FALSE, warning=FALSE}
gf_point(flipper_length_mm/10 ~ body_mass_g/1000, 
         data=penguins) %>%
  gf_labs(y = "Flipper length (cm)", x = "Body mass (kg)") 
```

Each penguin has a specific mass and flipper length. To look at the penguins with a mass of around 4 kg, you can see that the different penguins have a variety of flipper lengths. That's typical natural variability.

A function graph can be constructed in the same way. Start with a table reporting the output of the function for a variety of inputs, like this:

```{r echo=FALSE}
Sigmoid1 <- tibble::tibble(input = seq(-3, 3, length=11), output = pnorm(input)) 
Sigmoid1 %>%
  knitr::kable() %>% 
  kableExtra::kable_styling()
```
Then make a point plot of the two columns in the table:

```{r echo=FALSE, fig.cap="A point plot of the table."}
gf_point(output ~ input, data = Sigmoid1)
```
The graph shows the shape of the sigmoid function, one of our naked modeling functions. Except ... the domain of the sigmoid is the entire number line from $-\infty$ to $\infty$. 

### Asymptotes of functions

There's no need to plot out the entire domain. We know that all the "action" is happening near zero and that for inputs further to the left the function value heads toward zero. Similarly, for inputs far to the right, the function value heads toward zero. We have a particular mathematical notation for this sort of "far to the left" idea. In mathematical notation, we write the situation for the sigmoid this way:

$$\lim_{x \rightarrow -\infty} \text{dnorm}(x) = 0\ \ \ \mbox{and}\ \ \ \lim_{x \rightarrow -\infty}\text{dnorm}(x) = 1$$
This information about the function output is called the ***horizontal asymptotes*** of the function. It's expected of a mathematically literate person that they know by heart the asymptotes of the basic modeling functions, just as a geographically literate person knows Africa is a continent and Ghana is a country in Africa. We'll say more about horizontal asymptotes later. For now, note that such expected knowledge enables us to convey the shape of the function by plotting just a limited, but well chosen, part of the domain. 

The graph drawn from the data table is incomplete. The domain of the sigmoid function is the entire number line---all numbers---but the graphic shows only a handful of input values. 

It's perhaps common sense that you can find the function output for an input that isn't shown on the point plot by ***interpolating*** between the points that are shown. For instance, put a straight-line betwen consecutive points:

```{r echo=FALSE, fig.cap="Interpolating between the data points"}
gf_point(output ~ input, data = Sigmoid1) %>%
  gf_line()
```

With the gaps between points filled in by interpolation, you can use the graphic to read off the output corresponding to every input in the graphic domain. (And *vice versa*: you can find an input that corresponds to any given output in the range of the function.)

Typically a function's graph is drawn using many more points, so closely spaced that you can't see a gap. Since you can't see the gaps, you won't be misled by the sharp angles between consecutive line segments connecting the points. Like this:

```{r sigmoid-graph, echo=FALSE}
slice_plot(pnorm(x) ~ x, domain(x=c(-3, 3)))
```

A more traditional, mathematical definition of a function graph is the set of coordinate pairs which are a legitimate input/output pairs of the function. Placing ink at all such legitimate pairs displays the graph.

::: {.takenote}
In the data point plot of the penguin flipper length vs body mass, there are generally multiple penguins with the same body mass but different flipper lengths. In mathematics, part of the ***definition*** of the term "function" is that a function has ***only one output*** for any given input. Thus, the graph of a function with one input will always consist of a single ***curve***, as opposed to the ***cloud of points*** often seen in data.
:::

## EXERCISES in draft

Show some graphs, ask which ones are mathematical functions, which ones have a unique inverse, what is the output corresponding to a given input, what is the input for a given output, what is the range of the function, .... 


## Inputs to output 

You can easily evaluate a function for a given input from its graph. As you know, just put your finger at the horizontal coordinate for the input. Then move your finger upward to reach the point on the curve directly above that horizontal coordinate. You read off the value of the function at that input by reference to the scale on the vertical axis.

It's not possible to show with a graph the whole of a function whose domain is $-\infty$ to $\infty$. Consequently, when drawing a graph we choose to show only that part of the domain that we expect will be relevant to our needs.

Sometimes, the graphic's domain includes parts that are not in the domain of the function being drawn. In such cases, the function's graph does not extend into the invalid part of the graphic domain, as in this plot of a function whose domain is only the positive numbers.

```{r echo=FALSE, warning=FALSE, message=FALSE}
slice_plot(log(x) ~ x, domain(x=c(-5, 5)), npts=500) %>%
  gf_labs(y = "Output", x = "Input") %>%
  gf_lims(y = c(-3,3), x=c(-5, 5))
```

This function has a range that runs from $-\infty$ to $\infty$, but the limits of paper and display mean that we can show only part of this range. With experience, you'll learn to read the hints in a graph that the underlying function might have a range larger than the one shown in the graphic.

## Outputs to inputs

Graphs are relatively modern, coming into mainstream use only in the 1700s. Much of mathematics was developed before graphs were invented. One consequence of this is that function tasks that are easy using a graph might be very hard with the previous ways of implementing functions. This is analogous to the way that arithmetic is pretty easy with Arabic numerals, but really hard with Roman numerals.

A function graph makes it easy to evaluate the ***function inverse***. For all the basic modeling functions we have a way to calculate numerically the output for any given input (in the function's domain). 

Often, working with a function goes another way: you know the output and you want to find a corresponding input. It's easy to do this with a graph. Pick the position on the vertical axis that represents the given input. Then trace horizontally to where the ink is. From there, trace vertically to read off the value of an input that would produce the given output.

Mathematicians are careful to distinguish between functions where there is a ***unique*** input that generates each given output, and functions where there can be more than one input that generates the same output. Functions with a one-to-one relationship between output and input are called "invertible."

Invertible or not, it is a common procedure for working with functions to find *an* input corresponding to a specific, given output. In high-school algebra, this was called "solving for $x$." A special case of solving is finding the ***roots of a polynomial***. The name we give to the procedure is ***zero finding***, which correctly points out that we are trying to **find** an input.

## Graphs of functions with two inputs

We can draw graphs of functions with two inputs. Now the points need to be marked in a 3-dimensional space: one axis for each of the two inputs and another axis for the output. Like this:

```{r echo=FALSE, fig.cap="(Figure Fun-1b-1.2)"}
f2 <- rfun( ~ input_1 + input_2, seed=932)
interactive_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)))
```

It is very hard to read a graph of a function with two inputs. Think of the graph as a kind of tent suspended over a domain of ground. The graph itself is a surface. To show the graph on a display, some tricks of the trade are used: color to give an additional scale for the output; computer graphics to let us rotate the surface to look at it from various perspectives, added grid lines and marks on the surface to help us read out the numerical value.

## Contour plots

::: {.objectives latex-data=""}

```{r echo=FALSE, results="asis"}
state_objective("F-21", "Interpret a contour plot of a function of two input variables, to include estimating function values and locations of peaks and valleys.")
```
:::

A mathematical graph is just one way to draw a picture of a function with two inputs. There are other ways. One helpful mode of picture is called a ***contour plot***, familiar to many non-mathematicians in the form of topgraphical maps showing landscape elevation as a function of latitude and longitude. Here's a contour plot of the same function shown in the previous graph:

```{r echo=FALSE, fig.cap="(Fig-1b-2.1)"}
f2 <- rfun( ~ input_1 + input_2, seed=932)
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0)
```

This contour plot is a topographical map of the mathematical graph in Figure Figure (Fun-1b-1.2)

It may take some practice to learn to read contour plots fluently but it is a skill that's worthwhile to have. Note that the graphics frame is the Cartesian space of the two inputs. The output is presented as ***contour lines***. Each contour line has a label giving the numerical value of the function output. Each of the input value pairs on a given contour line corresponds to an output at the level labeling that contour line. To find the output for an input pair that is *not* on a contour line, you ***interpolate*** between the contours on either side of that point.

For example, the input pair (0, 0)---which is at the bottom of the frame, midway from left to right---falls between the contours labeled "20" and "22." This means that the output corresponding to input (0, 0) is somewhere between 20 and 22. The point is much closer to the contour labeled "20", so it's reasonable to see the output value as 20.5. This is, of course, an approximation, but that's the nature of reading numbers off of graphs.

Often, the specific numerical value at a point is not of primary interest. Instead, we may be interested in how steep the function is at a point, which is indicated by the spacing between contours. When contours are closely spaced, the hillside is steep. Where contours are far apart, the hillside is not steep, perhaps even flat.

Another common task for interpreting contour plots is to locate the input pair that's at a local high point or low point: the top of a hill or the bottom of a hollow. Such points are called ***local argmax*** or ***local argmin*** respectively. The *output* of the function at a local argmax is called the ***local maximum***; similarly for a local argmin, where the output is called a ***local minimum***. (The word "argmax" is a contraction of "argument of the maximum." We will tend to use the word "input" instead of "argument", but it means exactly the same thing to say "the inputs to a function" as to says "the arguments of a function.")

Still other common tasks for reading contour plots are to start at a given input pair and figure out 1) the direction to move which is most steeply uphill, or 2) the direction to move which will keep the function output the same.

It can be helpful to look at a contour map and interpret the contours as representing geographical features: hills, valleys, crests, coves, hollows, and so on.

Then, for (Fun-1c) translate between a contour plot and a graph of a function with one input. (We can think about this as a function of two inputs, where we hold one of the inputs constant, that is, always the same. )

## Slice plots

::: {.objectives data-latex=""}
```{r echo=FALSE, results="asis"}
state_objective("F-23", "Know what is meant by a slice of function of two variables.  Be able to determine if a function is increasing, decreasing, or constant when moving horizontally or vertically on the contour plot.")
```
:::

As mentioned before, ***mathematical modeling*** is the process of constructing mathematical representations of situations or phenomena of interest. In CalcZ, we are primarily interested in using ***functions*** as such representations.

Almost always, when mathematically modeling a real-world situation or phenomenon, we do not try to capture every nuance of every relationship that might exist in the real world. We leave some things out. Such simplifications make modeling problems tractable and encourage us to identify the most important features of the most important relationships.

On the other hand, it's easy to go wrong and leave out something that's important. To mitigate this risk, many modeling projects involve a ***modeling cycle*** where we propose a candidate model, examine the consequence of that model to see if it corresponds well to the parts of reality that are important to us in our task, and modify the model as needed to produce a new and better candidate.

In this spirit, it's useful always to assume that our models are leaving something out and that a more complete model involves a function with more inputs than the present candidate. The present candidate model should be considered as a ***slice*** of a more complete model. Our slice leaves out one or more of the variables in a more complete model.

To illustrate this, suppose that we have a "more complete model" in the form of a function of two inputs, as shown in the contour plot below.

```{r (Fig-1c.1), echo=FALSE}
f2 <- rfun( ~ input_1 + input_2, seed=96)
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0)
```

As you become practiced reading contour plots, you might prefer to read this one as a hilltop (shaded yellow) side-by-side with a hollow or bowl (shaded purple), with green, almost level flanks at the left and right edges of the frame.

The most common forms of ***slice*** involve constructing a simpler function that has one input but not the other. For example, our simpler function might ignore input #2. There are different ways of collapsing the function of two inputs into a function of one input. An especially useful way in calculus is to take the two-input function and set one of the inputs to a ***constant value***.

For instance, suppose we set input #2 to the constant value 1.5. This means that we can consider any value of input #1, but input #2 has been replaced by 1.5. In Figure Fig-1c.2, we've marked in red the points in the contour plot that give the output of the simplified function.

```{r (Fig-1c.2), echo=FALSE, out.width="50%", fig.show="hold", warning=FALSE}
f2 <- rfun( ~ input_1 + input_2, seed=96)
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0) %>%
  gf_hline(yintercept=1.5, color="red", size=2) %>%
  gf_labs(title="Contour plot of function of two inputs")
slice_plot(f2(input_1, input_2=1.5) ~ input_1, domain(input_1=c(-5, 5))) %>%
  gf_labs(title="Graph of function output versus input #1")
```

Each point along the red line corresponds to a specific value of input #1. From the contours, we can read the output corresponding to each of those values of input #1. This relationship, output versus input #1 can be drawn as a mathematical graph (to the right of the contour plot). Study that graph until you can see how the rising and falling parts of the graph correspond to the contours being crossed by the red line.

Slices can be taken in any direction or even along a curved path! The blue line below the slice constructed by letting input #2 vary and holding input #1 and the constant value 0.

```{r (Fig-1c.3), echo=FALSE, out.width="50%", fig.show="hold", warning=FALSE}
contour_plot(f2(input_1, input_2) ~ input_1 + input_2,
                 domain(input_1=c(-5, 5), input_2 = c(0, 4)),
             skip=0) %>%
  gf_vline(xintercept=0, color="blue", size=2) %>%
  gf_labs(title="Contour plot of function of two inputs")
slice_plot(f2(input_1 = 0 , input_2) ~ input_2, domain(input_2=c(0, 5))) %>%
  gf_labs(title="Graph of function output versus input 2")
```

## Creating graphics

::: {.objectives}
```{r echo=FALSE, results="markup"}
state_objective("F-32-R", "Use the `slice_plot()`, `contour_plot()`, and `domain()` functions in R/`mosaic`.")
```
:::


::: {.todo}
NO CONTENT YET
:::


```{exercise}
```
`r knitr::knit_child(exercise_file("03", "drawing.Rmd"))`

